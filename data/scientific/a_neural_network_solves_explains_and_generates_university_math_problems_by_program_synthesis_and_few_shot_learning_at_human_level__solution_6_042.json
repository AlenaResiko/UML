{
  "authors": [
    "Iddo Drori",
    "Sarah Zhang",
    "Reece Shuttleworth",
    "Leonard Tang",
    "Albert Lu",
    "Elizabeth Ke",
    "Kevin Liu",
    "Linda Chen",
    "Sunny Tran",
    "Newman Cheng",
    "Roman Wang",
    "Nikhil Singh",
    "Taylor L. Patti",
    "Jayson Lynch",
    "Avi Shporer",
    "Nakul Verma",
    "Eugene Wu",
    "Gilbert Strang"
  ],
  "date_published": "2021-12-31",
  "raw_tex": "\\section{Solutions for MIT 6.042: Mathematics for Computer Science}\n\\label{sec:solution-6.042}\n\n\\paragraph{Prereq} Calculus I (GIR)\n\\paragraph{Units} 5-0-7\n\\paragraph{Syllabus} Elementary discrete mathematics for science and engineering, with a focus on mathematical tools and proof techniques useful in computer science. Topics include logical notation, sets, relations, elementary graph theory, state machines and invariants, induction and proofs by contradiction, recurrences, asymptotic notation, elementary analysis of algorithms, elementary number theory and cryptography, permutations and combinations, counting tools, and discrete probability.\n\n\\begin{longtable}{|p{3.5cm}|p{11.5cm}|}\n\\caption{MIT 6.042, Question 1: Original question, Codex input and code and code explanation, Program solution, Solution type, GPT-3 response and evaluation}\\\\\n\\hline\nTopic & \nNumber Theory\n\\\\\n\\hline\nOriginal question & \nFind the multiplicative inverse of $17$ modulo $72$ in the range ${0, 1, . . . , 71}.$\\\\\n\\hline\nCodex input &\nFind the multiplicative inverse of 17 mod 72.\\\\\n\\hline\nCodex code & \\begin{lstlisting}\ndef multiplicative_inverse(a, b):\n   \"\"\"\n   Find the multiplicative inverse of a mod b.\n   \"\"\"\n   for i in range(1, b):\n   if (a * i)   b   1:\n   return i\n   return None\n\nprint(multiplicative_inverse(17, 72))\n\\end{lstlisting}\\\\\n\\hline\nProgram solution & $17$\n\\\\\n\\hline\nSolution type & Automatic Zero-Shot \\\\\n\\hline\nCodex code explanation & \n1. It's iterating through the range of 1 to b.\\newline\n2. It's checking if a * i \\ b   1.\\newline\n3. If it is, it returns i.\\newline\n4. If it isn't, it returns None.\\\\\n\\hline\nGPT-3 response & \n\\begin{lstlisting}\nfor i in range(72):\n   if (17 * I)   72   1:\n   print(I)\n   break\n\\end{lstlisting} \\\\\n\\hline\nGPT-3 evaluation & Incorrect\\\\\n\\hline\n\\end{longtable}\n\n\n\\begin{longtable}{|p{3.5cm}|p{11.5cm}|}\n\\caption{MIT 6.042, Question 2: Original question, Codex input and code and code explanation, Program solution, Solution type, GPT-3 response and evaluation}\\\\\n\\hline\nTopic & \nNumber Theory\n\\\\\n\\hline\nOriginal question & \nFind a number $x \\in {0, 1, . . . , 112}$ such that $11x \\equiv 1$ (mod 113).\\\\\n\\hline\nCodex input &\nSame as original question\\\\\n\\hline\nCodex code & \\begin{lstlisting}\ndef find_x(n):\n   for x in range(n):\n   if (11*x)   n   1:\n   return x\n   return None\n\nprint(find_x(113))\n\\end{lstlisting}\\\\\n\\hline\nProgram solution & $72$\n\\\\\n\\hline\nSolution type & Automatic Zero-Shot \\\\\n\\hline\nCodex code explanation & \n1. It's iterating through all the numbers from 0 to 112. \\newline\n2. For each number, it's checking if $11x \\equiv 1$ (mod 113).\\newline\n3. If it finds a number that satisfies the equation, it returns that number.\\newline\n4. If it doesn't find a number that satisfies the equation, it returns None.\n\\\\\n\\hline\nGPT-3 response & \n\\begin{lstlisting}\nfor i in range(113):\n   if 11 * i   113   1:\n   print(i)\n   break\n\\end{lstlisting}\n\\\\\n\\hline\nGPT-3 evaluation & Correct\\\\\n\\hline\n\\end{longtable}\n\n\n\\begin{longtable}{|p{3.5cm}|p{11.5cm}|}\n\\caption{MIT 6.042, Question 3: Original question, Codex input and code and code explanation, Program solution, Solution type, GPT-3 response and evaluation}\\\\\n\\hline\nTopic & \nProbability\n\\\\\n\\hline\nOriginal question & \nFinalphobia is a rare disease in which the victim has the delusion that he or she is being subjected to an intense mathematical examination. A person selected uniformly at random has finalphobia with probability $\\frac{1}{100}$. A person with finalphobia has shaky hands with probability $\\frac{9}{10}$. A person without finalphobia has shaky hands with probability $\\frac{1}{20}$. What is the probablility that a person selected uniformly at random has finalphobia, given that he or she has shaky hands? \\\\\n\\hline\nCodex input &\nFinalphobia is a rare disease in which the victim has the delusion that he or she is being subjected to an intense mathematical examination. A person selected uniformly at random has finalphobia with probability 1/100. A person with finalphobia has shaky hands with probability 9/10. A person without finalphobia has shaky hands with probability 1/20. What is the probability that a person selected uniformly at random has finalphobia, given that he or she has shaky hands?\\\\\n\\hline\nCodex code & \\begin{lstlisting}\ndef find_solution():\n   p_f   1/100\n   p_s   9/10\n   p_n   1/20\n   p_f_s   p_f * p_s / (p_f * p_s + p_n * (1 - p_s))\n   return p_f_s\nfind_solution()\n\\end{lstlisting}\\\\\n\\hline\nProgram solution & $0.1538$\n\\\\\n\\hline\nSolution type & Automatic Few-Shot \\\\\n\\hline\nCodex code explanation & \n1. We are given the probability of having finalphobia, p\\_f, and the probability of having shaky hands, p\\_s.\\newline\n2. We are also given the probability of not having finalphobia, 1 - p\\_f, and the probability of having shaky hands, p\\_n.\\newline\n3. We want to find the probability of having finalphobia, given that we have shaky hands.\n4. We can use Bayes' Theorem to find this probability.\\newline\n5. Bayes' Theorem states that P(A|B)   P(B|A) * P(A) / P(B).\\newline\n6. We can use this to find the probability of having finalphobia, given that we have shaky hands.\\newline\n7. We can find P(B) by adding the probabilities of having shaky hands, given that we have finalphobia and given that we don't have finalphobia.\\newline\n8. We can then plug these values into Bayes' Theorem to find the probability of having finalphobia, given that we have shaky hands.\n\\\\\n\\hline\nGPT-3 response & \n\\# P(F|S)   P(S|F)P(F)/P(S)\n\\# P(S)   P(S|F)P(F) + P(S|~F)P(~F)\n\\# P(S)   9/10*1/100 + 1/20*(1-1/100)\n\\# P(S)   9/1000 + 1/20 - 1/2000\n\\# P(S)   91/5000\n\\# P(F|S)   9/10*1/100/91/5000\n\\# P(F|S)   10/91\n\\\\\n\\hline\nGPT-3 evaluation & Incorrect \\\\\n\\hline\n\\end{longtable}\n\n\n\\begin{longtable}{|p{3.5cm}|p{11.5cm}|}\n\\caption{MIT 6.042, Question 4: Original question, Codex input and code and code explanation, Program solution, Solution type, GPT-3 response and evaluation}\\\\\n\\hline\nTopic & \nProbability\n\\\\\n\\hline\nOriginal question & \nSuppose that you roll five 6-sided dice that are fair and mutually independent. What is the probability that all five dice show different values?\\\\\n\\hline\nCodex input &\nYou roll five 6-sided fair dice and mutually independent. Write a program to compute the probability that all five dice show different values.\\\\\n\\hline\nCodex code & \\begin{lstlisting}\nimport random\n\ndef roll_dice():\n   return random.randint(1, 6)\n\ndef roll_all_dice():\n   return [roll_dice() for _ in range(5)]\n\ndef all_different(dice):\n   return len(set(dice))   5\n\ndef main():\n   n_trials   100000\n   n_success   0\n   for _ in range(n_trials):\n   if all_different(roll_all_dice()):\n   n_success + 1\n   print(n_success / n_trials)\n\nif __name__   '__main__':\n   main()\n\\end{lstlisting}\\\\\n\\hline\nProgram solution & $0.09228$\n\\\\\n\\hline\nSolution type & Automatic Zero-Shot\\\\\n\\hline\nCodex code explanation & \n1. We define a function roll\\_dice() that returns a random integer between 1 and 6.\\newline\n2. We define a function roll\\_all\\_dice() that returns a list of five random integers between 1 and 6.\\newline\n3. We define a function all\\_different() that takes a list of integers and returns True if all the integers are different and False otherwise.\\newline\n4. We define a function main() that does the following:\\newline\n   a. It sets n\\_trials to 100000.\\newline\n   b. It sets n\\_success to 0.\\newline\n   c. It loops n\\_trials times, each time doing the following:\\newline\n   i. It rolls all five dice.\\newline\n   ii. If all five dice show different values, it increments n\\_success by 1.\\newline\n   d. It prints the fraction of trials that were successful.\\newline\n5. We call main().\n\\\\\n\\hline\nGPT-3 response & \n\\# The probability of all five dice showing different values is 1/6\\^5.\n\\\\\n\\hline\nGPT-3 evaluation & Incorrect\\\\\n\\hline\n\\end{longtable}\n\n\n\\begin{longtable}{|p{3.5cm}|p{11.5cm}|}\n\\caption{MIT 6.042, Question 5: Original question, Codex input and code and code explanation, Program solution, Solution type, GPT-3 response and evaluation}\\\\\n\\hline\nTopic & \nProbability\n\\\\\n\\hline\nOriginal question & \nMIT students sometimes delay laundry for a few days. Assume all random values described below are mutually independent. A busy student must complete 3 problem sets before doing laundry. Each problem set requires 1 day with probability $\\frac{2}{3}$ and 2 days with probability $\\frac{1}{3}$. Let B be the number of days a busy student delays laundry. What is $\\mathbb{E}(B)$?\\\\\n\\hline\nCodex input &\nMIT students sometimes delay laundry for a few days. Assume all random values described below are mutually independent. Days for illness recovery is ua*b where a and b are independent dice rolls. What's the expected value of u?\\\\\n\\hline\nCodex code & \\begin{lstlisting}\nimport numpy as np\n\na   np.random.randint(1,7,size100000)\nb   np.random.randint(1,7,size100000)\n\nu   a*b\n\nprint(np.mean(u))\n\\end{lstlisting}\\\\\n\\hline\nProgram solution & $4$\n\\\\\n\\hline\nSolution type & Automatic Zero-Shot\\\\\n\\hline\nCodex code explanation & \n1. Generate 100000 random numbers between 1 and 6. \\newline\n2. Multiply each of these numbers by another 100000 random numbers between 1 and 6.\\newline\n3. Take the mean of the resulting 100000 numbers.\n\\\\\n\\hline\nGPT-3 response & \n\\# Let X be the number of days a problem set takes to complete.\n\\# Then, X ~ Bernoulli(2/3)\n\\# Let B be the number of days a busy student delays laundry.\n\\# Then, B   X + Y + Z, where X, Y, and Z are independent and identically distributed.\n\\# Therefore, B ~ Binomial(3, 2/3)\n\\# Ex(B)   3(2/3)   2\n\\\\\n\\hline\nGPT-3 evaluation & Incorrect\\\\\n\\hline\n\\end{longtable}\n\n\n\\begin{longtable}{|p{3.5cm}|p{11.5cm}|}\n\\caption{MIT 6.042, Question 6: Original question, Codex input and code and code explanation, Program solution, Solution type, GPT-3 response and evaluation}\\\\\n\\hline\nTopic & \nProbability\n\\\\\n\\hline\nOriginal question & \nMIT students sometimes delay laundry for a few days. Assume all random values described below are mutually independent. A relaxed student rolls a fair, 6-sided die in the morning. If he rolls a 1, then he does his laundry immediately (with zero days of delay). Otherwise, he delays for one day and repeats the experiment the following morning. Let R be the number of days a relaxed student delays laundry. What is $\\mathbb{E}(R)$?\\\\\n\\hline\nCodex input &\nRoll the 6 sided dice infinitely if you don't get a 1. Don't count the first dice roll toward days, so remember to subtract the right value from return days. return days-1. Roll infinitely until you encounter a 1. Write a program to compute the expected value for number of rolls until 1 is encountered?\\\\\n\\hline\nCodex code & \\begin{lstlisting}\nimport random\n\ndef dice_roll():\n   return random.randint(1,6)\n\ndef roll_until_one():\n   days   0\n   while True:\n   days + 1\n   if dice_roll()   1:\n   return days-1\n\ndef expected_rolls():\n   total_days   0\n   for i in range(1000000):\n   total_days + roll_until_one()\n   return total_days/1000000\n\nprint(expected_rolls())\n\\end{lstlisting}\\\\\n\\hline\nProgram solution & $5$\n\\\\\n\\hline\nSolution type & Automatic Zero-Shot\\\\\n\\hline\nCodex code explanation & \n1. We define a function that rolls a dice and returns a random number between 1 and 6.\\newline\n2. We define a function that rolls a dice until it gets a 1. It returns the number of days it took to get a 1.\\newline\n3. We define a function that rolls a dice until it gets a 1, 1,000,000 times. It returns the average number of days it took to get a 1.\n\\\\\n\\hline\nGPT-3 response & \n\\#Expected value of R is 6.\n\\\\\n\\hline\nGPT-3 evaluation & Incorrect\n\\\\\n\\hline\n\\end{longtable}\n\n\n\\begin{longtable}{|p{3.5cm}|p{11.5cm}|}\n\\caption{MIT 6.042, Question 7: Original question, Codex input and code and code explanation, Program solution, Solution type, GPT-3 response and evaluation}\\\\\n\\hline\nTopic & \nProbability\n\\\\\n\\hline\nOriginal question & \nMIT students sometimes delay laundry for a few days. Assume all random values described below are mutually independent. Before doing laundry, an unlucky student must recover from illness for a number of days equal to the product of the numbers rolled on two fair, 6-sided dice. Let U be the expected number of days an unlucky student delays laundry. What is $\\mathbb{E}(U)$? \\\\\n\\hline\nCodex input &\nRoll the 2 x 6-sided dice. The product of the two dice is number of days. What is the expected value for number of days?\\\\\n\\hline\nCodex code & \\begin{lstlisting}\nimport random\n\ndef roll_dice():\n   return random.randint(1,6), random.randint(1,6)\n\ndef expected_value(n):\n   total   0\n   for i in range(n):\n   total + roll_dice()[0] * roll_dice()[1]\n   return total / n\n\nprint(expected_value(1000000))\n\\end{lstlisting}\\\\\n\\hline\nProgram solution & $12.25$\n\\\\\n\\hline\nSolution type & Automatic Zero-Shot\\\\\n\\hline\nCodex code explanation & \n1. It's rolling two dice and multiplying the results.\\newline\n2. It's doing this a million times.\\newline\n3. It's adding up all the results.\\newline\n4. It's dividing by a million to get the average.\n\\\\\n\\hline\nGPT-3 response & \\#Expected value of the product of two dice is 7.\n\\\\\n\\hline\nGPT-3 evaluation & Incorrect\\\\\n\\hline\n\\end{longtable}\n\n\n\\begin{longtable}{|p{3.5cm}|p{11.5cm}|}\n\\caption{MIT 6.042, Question 8: Original question, Codex input and code and code explanation, Program solution, Solution type, GPT-3 response and evaluation}\\\\\n\\hline\nTopic & \nProbability\n\\\\\n\\hline\nOriginal question & \nI have twelve cards: 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6. I shuffle them and deal them in a row. What is the expected number of adjacent pairs with the same value?\\\\\n\\hline\nCodex input &\nI have twelve cards: 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6. I shuffle them and deal them in a row. Write a program that computes the average number of adjacent pairs with the same value over 10000 runs\\\\\n\\hline\nCodex code & \\begin{lstlisting}\nimport random\n\ndef run_simulation():\n   cards   [1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6]\n   random.shuffle(cards)\n   count   0\n   for i in range(len(cards) - 1):\n   if cards[i]   cards[i + 1]:\n   count + 1\n   return count\n\ndef main():\n   total   0\n   for i in range(10000):\n   total + run_simulation()\n   print(total / 10000)\n\nif __name__   \"__main__\":\n   main()\n\\end{lstlisting}\\\\\n\\hline\nProgram solution & $0.99$\n\\\\\n\\hline\nSolution type & Automatic Zero-Shot\\\\\n\\hline\nCodex code explanation & \n1. We create a list of cards.\\newline\n2. We shuffle the cards.\\newline\n3. We count the number of adjacent pairs with the same value.\\newline\n4. We repeat steps 2 and 3 10000 times.\\newline\n5. We divide the total number of adjacent pairs by 10000 to get the expected value.\n\\\\\n\\hline\nGPT-3 response & \n\\# The expected number of adjacent pairs with the same value is 3.\n\\\\\n\\hline\nGPT-3 evaluation & Incorrect\\\\\n\\hline\n\\end{longtable}\n\n\n\\begin{longtable}{|p{3.5cm}|p{11.5cm}|}\n\\caption{MIT 6.042, Question 9: Original question, Codex input and code and code explanation, Program solution, Solution type, GPT-3 response and evaluation}\\\\\n\\hline\nTopic & \nProbability\n\\\\\n\\hline\nOriginal question & \nScores for a final exam are given by picking an integer uniformly at random from the set {50, 51, . . . , 97, 98}. The scores of all 128 students in the class are assigned in this manner. Let S1, . . . , S128 be their scores. For i $\\in$ {1, . . . , 128}, what is E[Si] ?   \\\\\n\\hline\nCodex input &\nScores for a final exam are given by picking an integer uniformly at random from the set {50, 51, . . . , 97, 98}. \nThe scores of 128 students in a class are assigned in this manner. Write a program to compute the mean score?\\\\\n\\hline\nCodex code & \\begin{lstlisting}\nimport random\n\ndef mean(n):\n   sum   0\n   for i in range(n):\n   sum + random.randint(50, 98)\n   return sum/n\n\nprint(mean(128))\n\\end{lstlisting}\\\\\n\\hline\nProgram solution & $74$\n\\\\\n\\hline\nSolution type & Automatic Zero-Shot\\\\\n\\hline\nCodex code explanation & \n1. It's creating a function called mean that takes in a parameter n. \\newline\n2. It's creating a variable called sum and setting it equal to 0.\\newline\n3. It's creating a for loop that iterates n times.\\newline\n4. It's adding a random integer between 50 and 98 to the sum variable.\\newline\n5. It's returning the sum divided by n.\\newline\n6. It's calling the mean function with 128 as the parameter.\\newline\n7. It's printing the result.\n\\\\\n\\hline\nGPT-3 response & \n\\# E[Si]   (50 + 97)/2   73.5\n\\\\\n\\hline\nGPT-3 evaluation & Correct\\\\\n\\hline\n\\end{longtable}\n\n\n\\begin{longtable}{|p{3.5cm}|p{11.5cm}|}\n\\caption{MIT 6.042, Question 10: Original question, Codex input and code and code explanation, Program solution, Solution type, GPT-3 response and evaluation}\\\\\n\\hline\nTopic & \nProbability\n\\\\\n\\hline\nOriginal question & \nScores for a final exam are given by picking an integer uniformly at random from the set $\\{50, 51, . . . , 97, 98\\}$. The scores of all $128$ students in the class are assigned in this manner. Let $S_{1}, \\ldots, S_{128}$ be their scores. Find $Var(Si)$.   \\\\\n\\hline\nCodex input &\nScores for a final exam are given by picking an integer uniformly at random from the set {50, 51, . . . , 97, 98}. \nThe scores of 128 students in a class are assigned independently in this manner. Write a program to compute the variance of the score.\\\\\n\\hline\nCodex code & \\begin{lstlisting}\nimport numpy as np\n\ndef compute_variance(n):\n   scores   np.random.randint(50, 99, n)\n   return np.var(scores)\n\nprint(compute_variance(128))\n\\end{lstlisting}\\\\\n\\hline\nProgram solution & $200$\n\\\\\n\\hline\nSolution type & Automatic Zero-Shot\\\\\n\\hline\nCodex code explanation & \n1. Generate 128 random integers between 50 and 98.\\newline\n2. Compute the variance of the 128 random integers.\n\\\\\n\\hline\nGPT-3 response & \n\\# We can use the fact that the variance of a uniform distribution is 1/12.\n\\# So the variance of each student's score is 1/12.\n\\# So the variance of the sum of the scores is 128*1/12   16.\n\\\\\n\\hline\nGPT-3 evaluation & Incorrect\\\\\n\\hline\n\\end{longtable}\n\n\n\n\n\\begin{longtable}{|p{3.5cm}|p{11.5cm}|}\n\\caption{MIT 6.042, Question 11: Original question, Codex input and code and code explanation, Program solution, Solution type, GPT-3 response and evaluation}\\\\\n\\hline\nTopic & Probability\n\\\\\n\\hline\nOriginal question & Scores for a final exam are given by picking an integer uniformly at random from the set $\\{50, 51, \\ldots, 97, 98\\}$. The scores of all 128 students in the class are assigned independently in this manner. Let $S$ be the average of their scores. Find Var(S).\n\\\\\n\\hline\nCodex input & Write a function that uniformly samples 128 scores from {50,52 ... 98} and finds the mean of that sample. \nThen write a function that loops 100000 times and finds np.var of the samples.\n\\\\\n\\hline\nCodex code & \\begin{lstlisting}\ndef sample_mean(n):\n   return np.mean(np.random.choice(range(50,99), n))\n\ndef sample_var(n):\n   return np.var([sample_mean(n) for i in range(100000)])\n\nprint(sample_var(128))\n\\end{lstlisting}\\\\\n\\hline\nProgram solution & $1.5625$\n\\\\\n\\hline\nSolution type & Automatic Few-Shot\\\\\n\\hline\nCodex code explanation &\n1. sample\\_mean(n) returns the mean of n random integers between 50 and 98. \\newline\n2. sample\\_var(n) returns the variance of 100000 sample means of n random integers between 50 and 98.\n\\\\\n\\hline\nGPT-3 response & \n\\begin{lstlisting}\n# Var(S)   E(S^2) - E(S)^2\n# E(S^2)   sum(i^2*P(i))\n# E(S)   sum(i*P(i))I\n# P(i)I   1/49\n\nE_S   sum([i*1/49 for i in range(50, 99)])\nE_S2   sum([i**2*1/49 for i in range(50, 99)])\n\nVar_S   E_S2 - E_S**2\nprint(Var_S)\n\\end{lstlisting}\n\\\\\n\\hline\nGPT-3 evaluation & Incorrect\\\\\n\\hline\n\\end{longtable}\n\n\n\n\\begin{longtable}{|p{3.5cm}|p{11.5cm}|}\n\\caption{MIT 6.042, Question 12: Original question, Codex input and code and code explanation, Program solution, Solution type, GPT-3 response and evaluation}\\\\\n\\hline\nTopic & Probability\n\\\\\n\\hline\nOriginal question & Three 6.042 students\u2014Kirari, Noelle, and Cobeni\u2014are playing a game of Tan Tan Taan!. During each round of Tan Tan Taan!, each player is dealt 4 cards of their own, and one additional card is shared among all players, so that each player has 5 cards that they can use (the 4 cards of their own along with the single shared card). Cards are uniformly distributed from a 52-card deck. If you get four of a kind (for example, four aces or four 2\u2019s), you can continue playing in the next round. If you don\u2019t get four of a kind, you must quit and return to doing your 6.042 homework. Cards from round to round are mutually independent. This game is so fun that even if two of the three players must quit and return to their 6.042 homework, the third player will continue playing alone as long as they are able to. What is the expected number of rounds that Kirari will play?\n\\\\\n\\hline\nCodex input & Calculate the probability a 5 card hand has 4 of a kind.\n\\\\\n\\hline\nCodex code & \\begin{lstlisting}\nimport random\n\ndef main():\n   \"\"\"\n   Calculate the probability a 5 card hand has 4 of a kind.\n   \"\"\"\n   deck   create_deck()\n   five_card_hands   create_five_card_hands(deck)\n   four_of_a_kind_hands   get_four_of_a_kind_hands(five_card_hands)\n   probability   get_probability(five_card_hands, four_of_a_kind_hands)\n   print(probability)\n\ndef create_deck():\n   \"\"\"\n   Create a deck of 52 cards.\n   \"\"\"\n   deck   []\n   for rank in range(2, 15):\n   for suit in ['C', 'D', 'H', 'S']:\n   deck.append((rank, suit))\n   return deck\n\ndef create_five_card_hands(deck):\n   \"\"\"\n   Create a list of all possible 5 card hands from a deck.\n   \"\"\"\n   five_card_hands   []\n   for i in range(len(deck)):\n   for j in range(i + 1, len(deck)):\n   for k in range(j + 1, len(deck)):\n   for l in range(k + 1, len(deck)):\n   for m in range(l + 1, len(deck)):\n   five_card_hands.append([deck[i], deck[j], deck[k], deck[l], deck[m]])\n   return five_card_hands\n\ndef get_four_of_a_kind_hands(five_card_hands):\n   \"\"\"\n   Get all the hands that have 4 of a kind.\n   \"\"\"\n   four_of_a_kind_hands   []\n   for hand in five_card_hands:\n   if is_four_of_a_kind(hand):\n   four_of_a_kind_hands.append(hand)\n   return four_of_a_kind_hands\n\ndef is_four_of_a_kind(hand):\n   \"\"\"\n   Check if a hand has 4 of a kind.\n   \"\"\"\n   ranks   [card[0] for card in hand]\n   for rank in ranks:\n   if ranks.count(rank)   4:\n   return True\n   return False\n\ndef get_probability(five_card_hands, four_of_a_kind_hands):\n   \"\"\"\n   Get the probability a 5 card hand has 4 of a kind.\n   \"\"\"\n   probability   len(four_of_a_kind_hands) / len(five_card_hands)\n   return probability\n\nif __name__   \"__main__\":\n   main()\n\\end{lstlisting}\\\\\n\\hline\nProgram solution & $0.00024$\n\\\\\n\\hline\nSolution type & Automatic Zero-Shot \\\\\n\\hline\nCodex code explanation & \n1. Create a deck of 52 cards.\n\nThe deck is created by creating a list of 52 tuples, each tuple representing a card. The first element of the tuple is the rank of the card, and the second element is the suit of the card.\n\n2. Create a list of all possible 5 card hands from a deck.\n\nThe list of all possible 5 card hands is created by iterating through the deck, and for each iteration, iterating through the rest of the deck to create a second card, then iterating through the rest of the deck to create a third card, and so on.\n\n3. Get all the hands that have 4 of a kind.\n\nThe hands that have 4 of a kind are determined by iterating through the list of all possible 5 card hands, and checking if the hand has 4 of a kind.\n\n4. Get the probability a 5 card hand has 4 of a kind.\n\nThe probability a 5 card hand has 4 of a kind is the number of hands that have 4 of a kind divided by the total number of possible 5 card hands.\n\\\\\n\\hline\nGPT-3 response & \n\\# Kirari's expected number of rounds is 1.\n\\\\\n\\hline\nGPT-3 evaluation & Incorrect\\\\\n\\hline\n\\end{longtable}\n\n\n\\begin{longtable}{|p{3.5cm}|p{11.5cm}|}\n\\caption{MIT 6.042, Question 13: Original question, Codex input and code and code explanation, Program solution, Solution type, GPT-3 response and evaluation}\\\\\n\\hline\nTopic & Graph Theory\n\\\\\n\\hline\nOriginal question & What is the diameter of the following graph? graph   {'A': ['B'], B': ['A', 'C', 'H'], C': ['B', 'D', 'E'], D': ['C', 'E'], E': ['C', 'D', 'F', 'H'], F': ['E', 'G'], G': ['F'], H': ['B', 'E']}\n\\\\\n\\hline\nCodex input & What is the diameter of the following graph? The starting node doesn't count towards length so subtract 1 from the final answer. graph   {'A': ['B'], B': ['A', 'C', 'H'], C': ['B', 'D', 'E'], D': ['C', 'E'], E': ['C', 'D', 'F', 'H'], F': ['E', 'G'], G': ['F'], H': ['B', 'E']}. Remember to define the shortest path function. Use python3.\n\\\\\n\\hline\nCodex code & \\begin{lstlisting}\ndef shortest_path(graph, start, end, path[]):\n   path   path + [start]\n   if start   end:\n   return path\n   if not start in graph:\n   return None\n   shortest   None\n   for node in graph[start]:\n   if node not in path:\n   newpath   shortest_path(graph, node, end, path)\n   if newpath:\n   if not shortest or len(newpath) < len(shortest):\n   shortest   newpath\n   return shortest\n\ndef diameter(graph):\n   diameter   0\n   for node in graph:\n   for node2 in graph:\n   if node ! node2:\n   path   shortest_path(graph, node, node2)\n   if path:\n   if len(path) > diameter:\n   diameter   len(path) - 1\n   return diameter\n\ngraph   {'A': ['B'], 'B': ['A', 'C', 'H'], 'C': ['B', 'D', 'E'], 'D': ['C', 'E'], 'E': ['C', 'D', 'F', 'H'], 'F': ['E', 'G'], 'G': ['F'], 'H': ['B', 'E']}\nprint(diameter(graph))\n\\end{lstlisting}\\\\\n\\hline\nProgram solution & $5$\n\\\\\n\\hline\nSolution type & Automatic Few-Shot\\\\\n\\hline\nCodex code explanation & \n1. It's creating a graph with 8 nodes and 9 edges.\\newline\n2. It's finding the shortest path between each pair of nodes.\\newline\n3. It's finding the longest shortest path.\n\nThe longest shortest path is the diameter of the graph.\n\\\\\n\\hline\nGPT-3 response & 4\n\\\\\n\\hline\nGPT-3 evaluation & Incorrect\\\\\n\\hline\n\\end{longtable}\n\n\n\n\\begin{longtable}{|p{3.5cm}|p{11.5cm}|}\n\\caption{MIT 6.042, Question 14: Original question, Codex input and code and code explanation, Program solution, Solution type, GPT-3 response and evaluation}\\\\\n\\hline\nTopic & Combinatorics\n\\\\\n\\hline\nOriginal question & In how many different ways can the letters in the name of the popular 1980\u2019s band BANANARAMA be arranged?\n\\\\\n\\hline\nCodex input & Write a program to compute the number of arrangements of characters in the word BANANARAMA. Remember to discount arrangements of repeated letters.\n\\\\\n\\hline\nCodex code & \\begin{lstlisting}\ndef factorial(n):\n   if n   0:\n   return 1\n   else:\n   return n * factorial(n-1)\n\ndef permutations(word):\n   if len(word)   1:\n   return [word]\n   else:\n   result   []\n   for i in range(len(word)):\n   for p in permutations(word[:i] + word[i+1:]):\n   result.append(word[i] + p)\n   return result\n\ndef arrangements(word):\n   return len(set(permutations(word)))\n\ndef main():\n   print(arrangements('BANANARAMA'))\n\nif __name__   \"__main__\":\n   main()\n\\end{lstlisting}\\\\\n\\hline\nProgram solution & $15120$\n\\\\\n\\hline\nSolution type & Automatic Few-Shot\\\\\n\\hline\nCodex code explanation & \n1. The permutations function is a recursive function that takes a word as input and returns a list of all the permutations of that word.\\newline\n2. The arrangements function takes a word as input and returns the number of arrangements of that word.\\newline\n3. The arrangements function calls the permutations function to get a list of all the permutations of the word.\\newline\n4. The arrangements function then converts the list of permutations into a set, which removes all the duplicates.\\newline\n5. The arrangements function then returns the length of the set, which is the number of arrangements of the word.\n\\\\\n\\hline\nGPT-3 response & \n\\begin{lstlisting}\nimport math\n\ndef factorial(n):\n   if n   0:\n   return 1\n   else:\n   return n * factorial(n-1)\n\ndef permutation(n, r):\n   return factorial(n) / factorial(n-r)\n\ndef combination(n, r):\n   return permutation(n, r) / factorial(r)\n\ndef main():\n   print(permutation(8, 8))\n\nif __name__   \"__main__\":\n   main()\n\\end{lstlisting}\n\\\\\n\\hline\nGPT-3 evaluation & Incorrect \\\\\n\\hline\n\\end{longtable}\n\n\n\\begin{longtable}{|p{3.5cm}|p{11.5cm}|}\n\\caption{MIT 6.042, Question 15: Original question, Codex input and code and code explanation, Program solution, Solution type, GPT-3 response and evaluation}\\\\\n\\hline\nTopic & Probability\n\\\\\n\\hline\nOriginal question & You shuffle a deck of cards and deal your friend a 5-card hand. Suppose your friend says, \u201cI have the ace of spades.\u201d What is the probability that she has another ace?\n\\\\\n\\hline\nCodex input & Create a 52-card deck. Remove the spade ace. Simulate 4 card hands and compute the probability a hand has an ace.\n\\\\\n\\hline\nCodex code & \\begin{lstlisting}\nimport random\n\ndef create_deck():\n   \"\"\"\n   Create a 52-card deck.\n   \"\"\"\n   deck   []\n   for suit in ['hearts', 'clubs', 'diamonds', 'spades']:\n   for value in ['ace', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'jack', 'queen', 'king']:\n   deck.append((suit, value))\n   return deck\n\ndef remove_ace(deck):\n   \"\"\"\n   Remove the spade ace.\n   \"\"\"\n   for i in range(len(deck)):\n   if deck[i][1]   'ace' and deck[i][0]   'spades':\n   deck.pop(i)\n   break\n   return deck\n\ndef draw_hand(deck):\n   \"\"\"\n   Simulate 4 card hands and compute the probability a hand has an ace.\n   \"\"\"\n   ace_count   0\n   for i in range(10000):\n   hand   random.sample(deck, 4)\n   for card in hand:\n   if card[1]   'ace':\n   ace_count + 1\n   break\n   return ace_count / 10000\n\nif __name__   '__main__':\n   deck   create_deck()\n   deck   remove_ace(deck)\n   print(draw_hand(deck))\n\\end{lstlisting}\\\\\n\\hline\nProgram solution & $0.2218$\n\\\\\n\\hline\nSolution type & Manual\\\\\n\\hline\nCodex code explanation & \n1. Create a deck of 52 cards.\\newline\n2. Remove the spade ace.\\newline\n3. Draw 4 cards from the deck 10000 times.\\newline\n4. Count the number of times an ace is drawn.\\newline\n5. Divide the number of times an ace is drawn by the number of hands drawn.\n\nThe probability of drawing an ace is 0.49.\n\\\\\n\\hline\nGPT-3 response & \n\\#There are 4 aces in a deck of 52 cards.\n\\#The probability of drawing another ace is 4/52.\n\\\\\n\\hline\nGPT-3 evaluation & Incorrect\\\\\n\\hline\n\\end{longtable}\n\n\n\\begin{longtable}{|p{3.5cm}|p{11.5cm}|}\n\\caption{MIT 6.042, Question 16: Original question, Codex input and code and code explanation, Program solution, Solution type, GPT-3 response and evaluation}\\\\\n\\hline\nTopic & Graph Theory\n\\\\\n\\hline\nOriginal question & What is the chromatic number of the following graph? graph   {'A': ['B'], B': ['A', 'C', 'H'], C': ['B', 'D', 'E'], D': ['C', 'E'], E': ['C', 'D', 'F', 'H'], F': ['E', 'G'], G': ['F'], H': ['B', 'E']}\n\\\\\n\\hline\nCodex input & Find the chromatic number of a graph with adjacency matrix:\n [[0, 1, 0, 0, 0, 0, 0, 0],\n [1, 0, 1, 0, 0, 0, 0, 1],\n [0, 1, 0, 1, 1, 0, 0, 0],\n [0, 0, 1, 0, 1, 0, 0, 0],\n [0, 0, 1, 1, 0, 1, 0, 1],\n [0, 0, 0, 0, 1, 0, 1, 0],\n [0, 0, 0, 0, 0, 1, 0, 0],\n [0, 1, 0, 0, 1, 0, 0, 0]]\n\\\\\n\\hline\nCodex code & \\begin{lstlisting}\nimport numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\ndef chromatic_number(adj_matrix):\n   \"\"\"\n   Find the chromatic number of a graph with adjacency matrix\n   :param adj_matrix: adjacency matrix of graph\n   :return: chromatic number of graph\n   \"\"\"\n   # create graph from adjacency matrix\n   G   nx.from_numpy_matrix(adj_matrix)\n   # find chromatic number of graph\n   chromatic_number   nx.algorithms.coloring.greedy_color(G, strategy'largest_first')\n   return chromatic_number\n\nif __name__   '__main__':\n   # adjacency matrix of graph\n   adj_matrix   np.array([[0, 1, 0, 0, 0, 0, 0, 0],\n   [1, 0, 1, 0, 0, 0, 0, 1],\n   [0, 1, 0, 1, 1, 0, 0, 0],\n   [0, 0, 1, 0, 1, 0, 0, 0],\n   [0, 0, 1, 1, 0, 1, 0, 1],\n   [0, 0, 0, 0, 1, 0, 1, 0],\n   [0, 0, 0, 0, 0, 1, 0, 0],\n   [0, 1, 0, 0, 1, 0, 0, 0]])\n   # find chromatic number of graph\n   chromatic_number   chromatic_number(adj_matrix)\n   # print chromatic number\n   print(chromatic_number)\n   # create graph from adjacency matrix\n   G   nx.from_numpy_matrix(adj_matrix)\n   # draw graph\n   nx.draw(G, with_labelsTrue)\n   # show graph\n   plt.show()\n\\end{lstlisting}\n\\\\\n\\hline\nProgram solution & $3$\n\\\\\n\\hline\nSolution type & Manual\\\\\n\\hline\nCodex code explanation & \n1. Create a graph from the adjacency matrix\\newline\n2. Find the chromatic number of the graph\\newline\n3. Draw the graph\n\\\\\n\\hline\nGPT-3 response & \nThe chromatic number of the graph is 3.\n\\\\\n\\hline\nGPT-3 evaluation & Correct\\\\\n\\hline\n\\end{longtable}\n\n\n\\begin{longtable}{|p{3.5cm}|p{11.5cm}|}\n\\caption{MIT 6.042, Question 17: Original question, Codex input and code and code explanation, Program solution, Solution type, GPT-3 response and evaluation}\\\\\n\\hline\nTopic & Probability\n\\\\\n\\hline\nOriginal question & Suppose the 6.042 final consists of: 36 true/false questions worth 1 point each, 1 induction problem worth 15 points, and 1 giant problem that combines everything from the semester, worth 49 points. Grading goes as follows: The TAs choose to grade the easy true/false questions. For each individual point, they flip a fair coin. If it comes up heads, the student gets the point. Marten and Brooke split the task of grading the induction problem. With $\\frac{1}{3}$ probability, Marten grades the problem. His grading policy is as follows: Either he gets exasperated by the improper use of math symbols and gives 0 points (which happens with $\\frac{2}{5}$ probability), or he finds the answer satisfactory and gives 15 points (which happens with $\\frac{3}{5}$ probability). With $\\frac{2}{3}$ probability, Brooke grades the problem. Her grading policy is as follows: She selects a random integer point value from the range from 0 to 15, inclusive, with uniform probability. Finally, Tom grades the giant problem. He rolls two fair seven-sided dice (which have values from 1 to 7, inclusive), takes their product, and subtracts it from 49 to determine the score. Assume all random choices during the grading process are mutually independent. What is the variance on the 36 true/false questions?\n\\\\\n\\hline\nCodex input & Using numpy, calculate c, the probability of heads, 1/2, multiplied by the number of questions 36.\\newline\n$P(i_m)1/3$\\newline\n$P(i_{m_s})2/5$\\newline\n$p_{i_{m_s}}0$\\newline\n$P(i_{m_f})3/5$\\newline\n$p_{i_{m_f}}15$\\newline\n$P(i_b)2/3$\\newline\n$p_{i_b}$np.mean(np.array(list(range(16))))\\newline\nLet i be $P(i_m)*(P(i_{m_s})*p_{i_{m_s}}+P(i_{m_f})*p_{i_{m_f}}) + P(i_b)*p_{i_b}$ \\newline Create a list of all of the possible products of two fair dice 7-sided dice rolls multiplied together. Let g be the 49 minus the mean of the list. \\newline Use numpy to calculate the sum of c, i, g.\n\\\\\n\\hline\nCodex code & \\begin{lstlisting}\nimport numpy as np\n\nc   0.5 * 36\ni   (1/3) * (2/5) * 0 + (1/3) * (3/5) * 15 + (2/3) * np.mean(np.array(list(range(16))))\ng   49 - np.mean(np.array([i * j for i in range(1, 8) for j in range(1, 8)]))\n\nprint(c + i + g)\n\\end{lstlisting}\\\\\n\\hline\nProgram solution & $59$\n\\\\\n\\hline\nSolution type & Manual \\\\\n\\hline\nCodex code explanation & \n1. c is the cost of the first 5 days, which is 0.5 * 36   18 \\newline\n2. i is the cost of the next 3 days, which is (1/3) * (2/5) * 0 + (1/3) * (3/5) * 15 + (2/3) * np.mean(np.array(list(range(16)))) \\newline\n3. g is the cost of the last 7 days, which is 49 - np.mean(np.array([i * j for i in range(1, 8) for j in range(1, 8)]))\n\\\\\n\\hline\nGPT-3 response & \n\\# Let X be the random variable corresponding to the number of points on the 36 true/false questions.\n\\# Then E[X]   36*(1/2)   18 and Var(X)   36*(1/2)*(1/2)   9.\n\\\\\n\\hline\nGPT-3 evaluation & Incorrect\\\\\n\\hline\n\\end{longtable}\n\n\n\n\\begin{longtable}{|p{3.5cm}|p{11.5cm}|}\n\\caption{MIT 6.042, Question 18: Original question, Codex input and code and code explanation, Program solution, Solution type, GPT-3 response and evaluation}\\\\\n\\hline\nTopic & Probability\n\\\\\n\\hline\nOriginal question & Professor Plum, Mr. Green, and Miss Scarlet are all plotting to shoot Colonel Mustard. If one of these three has both an opportunity and the revolver, then that person shoots Colonel Mustard. Otherwise, Colonel Mustard escapes. Exactly one of the three has an opportunity with the following probabilities: Pr(Plum has opportunity)   $\\frac{1}{6}$. Pr(Green has opportunity)   $\\frac{2}{6}$. Pr(Scarlet has opportunity)   $\\frac{3}{6}$. Exactly one has the revolver with the following probabilities, regardless of who has an opportunity: Pr(Plum has revolver)   $\\frac{4}{8}$. Pr(Green has revolver)   $\\frac{3}{8}$.   Pr(Scarlet has revolver)   $\\frac{1}{8}$. What is the probability that Colonel Mustard is shot?\n\\\\\n\\hline\nCodex input & Professor Plum, Mr. Green, and Miss Scarlet are all plotting to shoot Colonel Mustard. If one of these three has both an opportunity and the revolver, then that person shoots Colonel Mustard. Otherwise, Colonel Mustard escapes. Exactly one of the three has an opportunity with the following probabilities:\nPr {Plum has opportunity}   1/6\nPr {Green has opportunity}   2/6\nPr {Scarlet has opportunity}   3/6\nExactly one has the revolver with the following probabilities, regardless of who has an opportuntity:\nPr {Plum has revolver}   4/8\nPr {Green has revolver}   3/8\nPr {Scarlet has revolver}   1/8 \nWhat is the probability that Colonel Mustard is shot?\nWrite a program.\n\\\\\n\\hline\nCodex code & \\begin{lstlisting}\nimport numpy as np\n\ndef colonel_mustard():\n   opportunity   np.random.choice(['Plum', 'Green', 'Scarlet'], p[1/6, 2/6, 3/6])\n   revolver   np.random.choice(['Plum', 'Green', 'Scarlet'], p[4/8, 3/8, 1/8])\n   if opportunity   revolver:\n   return 1\n   else:\n   return 0\n\nprint(np.mean([colonel_mustard() for i in range(100000)]))\n\\end{lstlisting}\\\\\n\\hline\nProgram solution & $0.27$\n\\\\\n\\hline\nSolution type & Automatic Few-Shot (1)\\\\\n\\hline\nCodex code explanation & \n1. It's choosing a random person from the three people with the probabilities given.\\newline\n2. It's choosing a random person from the three people with the probabilities given.\\newline\n3. If the two people are the same, then Colonel Mustard is shot.\\newline\n4. It's repeating this process 100000 times and taking the mean.\n\\\\\n\\hline\nGPT-3 response & \n\\#P(Plum has opportunity and revolver)   P(Plum has opportunity) * P(Plum has revolver)\n\\#P(Plum has opportunity and revolver)   1/6 * 4/8\n\\#P(Plum has opportunity and revolver)   1/24\n\n\\#P(Green has opportunity and revolver)   P(Green has opportunity) * P(Green has revolver)\n\\#P(Green has opportunity and revolver)   2/6 * 3/8\n\\#P(Green has opportunity and revolver)   1/12\n\n\\#P(Scarlet has opportunity and revolver)   P(Scarlet has opportunity) * P(Scarlet has revolver)\n\\#P(Scarlet has opportunity and revolver)   3/6 * 1/8\n\\#P(Scarlet has opportunity and revolver)   1/24\n\n\\#P(Colonel Mustard is shot)   P(Plum has opportunity and revolver) + P(Green has opportunity and revolver) + P(Scarlet has opportunity and revolver)\n\\#P(Colonel Mustard is shot)   1/24 + 1/12 + 1/24\n\\#P(Colonel Mustard is shot)   1/6\n\\\\\n\\hline\nGPT-3 evaluation & Incorrect\\\\\n\\hline\n\\end{longtable}\n\n\n\\begin{longtable}{|p{3.5cm}|p{11.5cm}|}\n\\caption{MIT 6.042, Question 19: Original question, Codex input and code and code explanation, Program solution, Solution type, GPT-3 response and evaluation}\\\\\n\\hline\nTopic & Combinatorics\n\\\\\n\\hline\nOriginal question & How many different paths are there from point $(0, 0, 0)$ to point $(12, 24, 36)$ if every step increments one coordinate and leaves the other two unchanged?\n\\\\\n\\hline\nCodex input & How many different paths are there from point (0, 0, 0) to point (12, 24, 36) if every step increments one coordinate and leaves the other two unchanged?\nUse math.factorial\n\\\\\n\\hline\nCodex code & \\begin{lstlisting}\nimport math\n\ndef main():\n   print(math.factorial(12+24+36) // (math.factorial(12) * math.factorial(24) * math.factorial(36)))\n\nif __name__   '__main__':\n   main()\n\\end{lstlisting}\\\\\n\\hline\nSolution & $553883078634868423069470550800$\n\\\\\n\\hline\nSolution type & Manual\\\\\n\\hline\nCodex code explanation & \n1. The code is calculating the number of ways to arrange 12 red, 24 green, and 36 blue balls in a row.\n\\\\\n\\hline\nGPT-3 response &\n\\begin{lstlisting}\ndef count_paths(x, y, z):\n   if x   12 and y   24 and z   36:\n   return 1\n   if x > 12 or y > 24 or z > 36:\n   return 0\n   return count_paths(x + 1, y, z) + count_paths(x, y + 1, z) + count_paths(x, y, z + 1)\n\nprint(count_paths(0, 0, 0))\n\\end{lstlisting}\n\\\\\n\\hline\nGPT-3 evaluation & Incorrect\\\\\n\\hline\n\\end{longtable}\n\n\n\n\\begin{longtable}{|p{3.5cm}|p{11.5cm}|}\n\\caption{MIT 6.042, Question 20: Original question, Codex input and code and code explanation, Program solution, Solution type, GPT-3 response and evaluation}\\\\\n\\hline\nTopic & Propositional Logic\n\\\\\n\\hline\nOriginal question & Express each of the following predicates and propositions in formal logic notation. The domain of discourse is the nonnegative integers, N. In addition to the propositional operators, variables and quantifiers, you may define predicates using addition, multiplication, and equality symbols, but no constants (like 0, 1, . . .). For example, the proposition \"n is an even number\" could be written $\\exists$m. (m + m   n).n is the sum of three perfect squares. \n\\\\\n\\hline\nCodex input & Same as original question\n\\\\\n\\hline\nCodex code &\n\\# n is the sum of three perfect squares.\n\n\\# $\\exists$ m,n,p. (m\\^2 + n\\^2 + p\\^2   n)\n\\\\\n\\hline\nProgram solution & $\\exists x. \\exists y. \\exists z.\\ (x^2 + y^2 + z^2   n)$\\\\\n\\hline\nSolution type & Automatic Zero-Shot\\\\\n\\hline\nCodex code explanation & 1. $\\exists$ m,n,p. (m\\^2 + n\\^2 + p\\^2   n)\n\\\\\n\\hline\nGPT-3 response & \n\\# n is the sum of three perfect squares.\n\\# $\\exists$ x,y,z. (x\\^2 + y\\^2 + z\\^2   n)\n\\\\\n\\hline\nGPT-3 evaluation & Correct\\\\\n\\hline\n\\end{longtable}\n\n\n\n\\begin{longtable}{|p{3.5cm}|p{11.5cm}|}\n\\caption{MIT 6.042, Question 21: Original question, Codex input and code and code explanation, Program solution, Solution type, GPT-3 response and evaluation}\\\\\n\\hline\nTopic & Propositional Logic\n\\\\\n\\hline\nOriginal question & Exactly 1/5th of the people in a town have Beaver Fever.   There are two tests for Beaver Fever, TEST1 and TEST2. When a person goes to a doctor to test for Beaver Fever, with probability 2/3 the doctor conducts TEST1 on him and with probability 1/3 the doctor conducts TEST2 on him. When TEST1 is done on a person, the outcome is as follows: If the person has the disease, the result is positive with probability 3/4. If the person does not have the disease, the result is positive with probability 1/4. When TEST2 is done on a person, the outcome is as follows: If the person has the disease, the result is positive with probability 1. If the person does not have the disease, the result is positive with probability 1/2. A person is picked uniformly at random from the town and is sent to a doctor to test for Beaver Fever. The result comes out positive. What is the probability that the person has the disease?\n\\\\\n\\hline\nCodex input & P(TEST\\_1)   2/3 \\newline\nP(TPR\\_1)   3/4 \\newline\nP(FPR\\_1)   1/4 \\newline\nP(TEST\\_2)   1/3 \\newline\nP(TPR\\_2)   1 \\newline\nP(FPR\\_2)   1/2 \\newline\nP(P)   1/5 \\newline\nP(N)   4/5 \\newline\nFind P(TEST\\_1)**2*P(P)*P(TPR\\_1)/(P(TEST\\_1)*P(P)*P(TPR\\_1)+P(TEST\\_1)*P(N)*P(FPR\\_1)) + P(TEST\\_2)**2*P(P)*P(TPR\\_2)/(P(TEST\\_2)*P(P)*P(TPR\\_2)+P(TEST\\_2)*P(N)*P(FPR\\_2))\n\\\\\n\\hline\nCodex code &\n\\begin{lstlisting}\ndef main():\n   p_test_1   2/3\n   p_tpr_1   3/4\n   p_fpr_1   1/4\n   p_test_2   1/3\n   p_tpr_2   1\n   p_fpr_2   1/2\n   p_p   1/5\n   p_n   4/5\n   p_tpr_1_2   p_test_1**2*p_p*p_tpr_1/(p_test_1*p_p*p_tpr_1+p_test_1*p_n*p_fpr_1)\n   p_tpr_2_2   p_test_2**2*p_p*p_tpr_2/(p_test_2*p_p*p_tpr_2+p_test_2*p_n*p_fpr_2)\n   print(p_tpr_1_2+p_tpr_2_2)\n\nif __name__   \"__main__\":\n   main()\n\\end{lstlisting}\\\\\n\\hline\nProgram solution & $5/13$\\\\\n\\hline\nSolution type & Manual\\\\\n\\hline\nCodex code explanation & \n1. The code above is calculating the probability of a positive test result given that the patient has the disease.\\newline\n2. The code above is calculating the probability of a positive test result given that the patient does not have the disease.\\newline\n3. The code above is calculating the probability of a negative test result given that the patient has the disease.\\newline\n4. The code above is calculating the probability of a negative test result given that the patient does not have the disease.\\newline\n5. The code above is calculating the probability of a positive test result.\\newline\n6. The code above is calculating the probability of a negative test result.\\newline\n7. The code above is calculating the probability of a patient having the disease.\\newline\n8. The code above is calculating the probability of a patient not having the disease.\\newline\n9. The code above is calculating the probability of a patient having the disease given a positive test result.\\newline\n10. The code above is calculating the probability of a patient having the disease given a negative test result.\\newline\n11. The code above is calculating the probability of a patient not having the disease given a positive test result.\\newline\n12. The code above is calculating the probability of a patient not having the disease given a negative test result.\n\\\\\n\\hline\nGPT-3 response & \n\\# Let A be the event that the person has the disease\n\\# Let B be the event that the person tests positive\n\n\\# P(A)   1/5\n\\# P(B|A)   3/4\n\\# P(B|A')   1/4\n\n\\# P(B)   P(B|A)P(A) + P(B|A')P(A')\n\\# P(B)   3/4(1/5) + 1/4(4/5)\n\\# P(B)   3/20 + 1/20\n\\# P(B)   1/5\n\n\\# P(A|B)   P(B|A)P(A)/P(B)\n\\# P(A|B)   3/4(1/5)/(1/5)\n\\# P(A|B)   3/4\n\\\\\n\\hline\nGPT-3 evaluation & Incorrect\\\\\n\\hline\n\\end{longtable}\n\n\n\n\\begin{longtable}{|p{3.5cm}|p{11.5cm}|}\n\\caption{MIT 6.042, Question 22: Original question, Codex input and code and code explanation, Program solution, Solution type, GPT-3 response and evaluation}\\\\\n\\hline\nTopic & Propositional Logic\n\\\\\n\\hline\nOriginal question & How many different solutions over the natural numbers are there to the following equation? $x^1 + x^2 + x^3 + . . . + x^8   100$ A solution is a specification of the value of each variable $x_i$. Two solutions are different if different values are specified for some variable $x_i$.\n\\\\\n\\hline\nCodex input & Write a program to find the number of positive integer solutions to the equation $x_1**1+x_2**2+x_3**3+x_4**4+x_5**5+x_6**6+x_7**7+x_8**8   100$. 100 is the highest number to consider for each variable.\n\\\\\n\\hline\nCodex code &\n\\begin{lstlisting}\ndef count_solutions(n):\n   count   0\n   for x1 in range(1, n+1):\n   for x2 in range(1, n+1):\n   for x3 in range(1, n+1):\n   for x4 in range(1, n+1):\n   for x5 in range(1, n+1):\n   for x6 in range(1, n+1):\n   for x7 in range(1, n+1):\n   for x8 in range(1, n+1):\n   if x1**1 + x2**2 + x3**3 + x4**4 + x5**5 + x6**6 + x7**7 + x8**8   n:\n   count + 1\n   return count\n\nprint(count_solutions(100))\n\\end{lstlisting}\\\\\n\\hline\nProgram solution & $107!/100!7!$\\\\\n\\hline\nSolution type & Manual\\\\\n\\hline\nCodex code explanation & \n1. It's creating a variable called count and setting it to 0.\\newline\n2. It's creating a for loop that iterates through the range of 1 to n+1.\\newline\n3. It's creating a second for loop that iterates through the range of 1 to n+1.\\newline\n4. It's creating a third for loop that iterates through the range of 1 to n+1.\\newline\n5. It's creating a fourth for loop that iterates through the range of 1 to n+1.\\newline\n6. It's creating a fifth for loop that iterates through the range of 1 to n+1.\\newline\n7. It's creating a sixth for loop that iterates through the range of 1 to n+1.\\newline\n8. It's creating a seventh for loop that iterates through the range of 1 to n+1.\\newline\n9. It's creating an eighth for loop that iterates through the range of 1 to n+1.\\newline\n10. It's creating an if statement that checks if the sum of the variables to the power of their respective numbers is equal to n.\\newline\n11. If the if statement is true, it adds 1 to the count variable.\\newline\n12. It returns the count variable.\n\\\\\n\\hline\nGPT-3 response & \n\\begin{lstlisting}\ndef count_solutions(target, powers):\n   \"\"\"\n   >>> count_solutions(100, [1, 2, 3, 4, 5, 6, 7, 8])\n   12\n   \"\"\"\n   if target   0:\n   return 1\n   elif target < 0 or powers   []:\n   return 0\n   else:\n   return count_solutions(target, powers[1:]) + count_solutions(target - powers[0], powers)\n\nif __name__   '__main__':\n   import doctest\n   doctest.testmod()\n\\end{lstlisting}\n\\\\\n\\hline\nGPT-3 evaluation & Incorrect\\\\\n\\hline\n\\end{longtable}\n\n\n\n\\begin{longtable}{|p{3.5cm}|p{11.5cm}|}\n\\caption{MIT 6.042, Question 23: Original question, Codex input and code and code explanation, Program solution, Solution type, GPT-3 response and evaluation}\\\\\n\\hline\nTopic & Probability\n\\\\\n\\hline\nOriginal question & Outside of their humdrum duties as 6.042 TAs, Sayan is trying to learn to levitate using only intense concentration and Jelani is launching a \u201cNelson 2008\u201d presidential campaign. Suppose that Sayan\u2019s probability of levitating is $\\frac{1}{6}$, Jelani\u2019s chance of becoming president is $\\frac{1}{4}$, and the success of one does not alter the other\u2019s chances. If at most one of them succeeds, what is the probability that Jelani becomes the president of the United States?\n\\\\\n\\hline\nCodex input & Suppose that Sayan\u2019s probability Sayan succeeding is 1/6, and Jelani's probability of succeeding is 1/4. Use numpy to find the probability at most one of Jelani and Sayan succeed.\\newline\nUse numpy to find the probability Jelani succeeds but Sayan does not succeed.\\newline\nDivide the former by the latter probability.\n\\\\\n\\hline\nCodex code & \\begin{lstlisting}\nimport numpy as np\n\n# Probability of Sayan succeeding\np_sayan   1/6\n\n# Probability of Jelani succeeding\np_jelani   1/4\n\n# Probability of at most one of Jelani and Sayan succeeding\np_at_most_one   1 - (p_sayan * p_jelani)\n\n# Probability of Jelani succeeding but Sayan not succeeding\np_jelani_succeed_sayan_not   p_jelani * (1 - p_sayan)\n\n# Probability of Jelani succeeding but Sayan not succeeding divided by probability of at most one of Jelani and Sayan succeeding\np_jelani_succeed_sayan_not / p_at_most_one\n\n# Probability of at least one of Jelani and Sayan succeeding\np_at_least_one   1 - p_at_most_one\n\\end{lstlisting}\\\\\n\\hline\nProgram solution & $0.217$\n\\\\\n\\hline\nSolution type & Manual\\\\\n\\hline\nCodex code explanation & \n1. We're calculating the probability of Sayan succeeding.\\newline\n2. We're calculating the probability of Jelani succeeding.\\newline\n3. We're calculating the probability of at most one of Jelani and Sayan succeeding.\\newline\n4. We're calculating the probability of Jelani succeeding but Sayan not succeeding.\\newline\n5. We're calculating the probability of Jelani succeeding but Sayan not succeeding divided by probability of at most one of Jelani and Sayan succeeding.\\newline\n6. We're calculating the probability of at least one of Jelani and Sayan succeeding.\n\\\\\n\\hline\nGPT-3 response & \n\\# Sayan's probability of levitating is 1/6, Jelani's chance of becoming president is 1/4\n\\# If at most one of them succeeds, what is the probability that Jelani becomes the president of the United States?\n\n\\# P(Jelani)   P(Jelani and not Sayan) + P(Jelani and Sayan)\n\\#   P(Jelani)P(not Sayan) + P(Jelani)P(Sayan)\n\\#   P(Jelani)(1 - P(Sayan)) + P(Jelani)P(Sayan)\n\\#   P(Jelani) - P(Jelani)P(Sayan) + P(Jelani)P(Sayan)\n\\#   P(Jelani) - P(Jelani)P(Sayan) + P(Jelani)P(Sayan)\n\\#   P(Jelani) - P(Jelani)P(Sayan) + P(Jelani)P(Sayan)\n\\#   P(Jelani) - P(Jelani)P(Sayan) + P(Jelani)P(Sayan)\n\\#   P(Jelani) - P(Jelani)P(Sayan) + P(Jelani)P(Sayan)\n\\#   P(Jelani) - P(Jelani)P(Sayan) + P(Jelani)P(Sayan)\n\\#   P(Jelani) - P(Jelani)P(Sayan) + P(Jelani)P(Sayan)\n\\#   P(Jelani) - P(Jelani)P(Sayan)\n\\\\\n\\hline\nGPT-3 evaluation & Incorrect\\\\\n\\hline\n\\end{longtable}\n\n\n\n\n\n\\begin{longtable}{|p{3.5cm}|p{11.5cm}|}\n\\caption{MIT 6.042, Question 24: Original question, Codex input and code and code explanation, Program solution, Solution type, GPT-3 response and evaluation}\\\\\n\\hline\nTopic & Combinatorics\n\\\\\n\\hline\nOriginal question & Find the coefficients of $x^{10}$ in $(x + (\\frac{1}{x}))^{100}$\n\\\\\n\\hline\nCodex input & Using sympy, find the coefficients of $x^{10}$ in $(x + (1/x))^{100}$\n\\\\\n\\hline\nCodex code & \\begin{lstlisting}\nfrom sympy import symbols, expand\n\nx   symbols('x')\n\nprint(expand((x + (1/x))**100).coeff(x, 10))\n\\end{lstlisting}\\\\\n\\hline\nProgram solution & $x^{100} + 100x^{98} + 4950x^{96} + 161700x^{94} + \\hdots{}$ \\newline\n$61448471214136179596720592960$\n\\\\\n\\hline\nSolution type & Automatic Zero-shot\\\\\n\\hline\nCodex code explanation & \n1. The code is using the expand function to expand the expression (x + (1/x))**100\\newline\n2. The expand function is then used to find the coefficient of x**10\n\\\\\n\\hline\nGPT-3 response & \nThere are 100 terms in the binomial expansion of $(x + (1/x))^{100}$, and the tenth term is $x^{10}$. The coefficient of $x^{10}$ is therefore 1.\n\\\\\n\\hline\nGPT-3 evaluation & Incorrect\\\\\n\\hline\n\\end{longtable}\n\n\n\n\n\\begin{longtable}{|p{3.5cm}|p{11.5cm}|}\n\\caption{MIT 6.042, Question 25: Original question, Codex input and code and code explanation, Program solution, Solution type, GPT-3 response and evaluation}\\\\\n\\hline\nTopic & Combinatorics\n\\\\\n\\hline\nOriginal question & Define a bijection between the natural numbers and the integers.\n\\\\\n\\hline\nCodex input & To define a bijection between natural number and integers, map the even and odd natural numbers to positive and negative integers. Divide by 2 and rounding down.\n\\\\\n\\hline\nCodex code & \\begin{lstlisting}\ndef even_odd_to_int(n):\n   if n   2   0:\n   return n // 2\n   else:\n   return -(n + 1) // 2\n\\end{lstlisting}\\\\\n\\hline\nProgram solution & To define a bijection between natural number and integers, map the even and odd natural numbers to positive and negative integers. Divide by 2 and rounding down.\n\\\\\n\\hline\nSolution type & Manual\\\\\n\\hline\nCodex code explanation & \n1. If n is even, then n // 2 is the integer division of n by 2.\\newline\n2. If n is odd, then -(n + 1) // 2 is the integer division of -(n + 1) by \\newline\n3. The integer division of -(n + 1) by 2 is the same as the integer division of -n by 2, because -(n + 1)   -n - 1.\\newline\n4. The integer division of -n by 2 is the same as the integer division of n by 2, because -n   -1 * n.\\newline\n5. So, if n is odd, then -(n + 1) // 2 is the same as n // 2.\n\\\\\n\\hline\nGPT-3 response & \nThe natural numbers are the counting numbers: 1, 2, 3, 4, 5, and so on. \\newline The integers are the whole numbers: 0, 1, 2, 3, 4, and so on.\\newline \n\nA bijection between the two sets can be defined as follows:\\newline \n$1 \\longrightarrow 0$ \\newline \n$2 \\longrightarrow 1$\\newline \n$3 \\longrightarrow 2$\\newline \n$4 \\longrightarrow 3$\\newline \n$5 \\longrightarrow 4$\\newline \nand so on.\n\\\\\n\\hline\nGPT-3 evaluation & Incorrect\\\\\n\\hline\n\\end{longtable}",
  "title": "A Neural Network Solves, Explains, and Generates University Math Problems by Program Synthesis and Few-Shot Learning at Human Level"
}
