{
  "authors": [
    "Iddo Drori",
    "Gaston Longhitano",
    "Mao Mao",
    "Seunghwan Hyun",
    "Yuke Zhang",
    "Sungjun Park",
    "Zachary Meeks",
    "Xin-Yu Zhang",
    "Ben Segev",
    "Howard Yong",
    "Nakul Verma",
    "Avi Shporer",
    "Alon Amit",
    "Madeleine Udell"
  ],
  "date_published": "2025-02-14",
  "raw_tex": "\\UseRawInputEncoding\n\n\\section{Combinatorics Game Code}\n\\label{appendix:H}\n\n\\paragraph{Program synthesis and simulation.}\nGiven the problem in English and game representation, an LLM writes Python code that implements the state, observation, transition, and reward functions $\\mathcal{S}, \\Omega, \\mathcal{O}, T, R$, and simulates game-play trajectories $\\tau \\;\\; \\bigl(s_0, o_0, a_0, r_0, s_1, o_1, a_1, r_1,\\ldots\\bigr)$, where $s_t \\sim T(s_{t-1}, a_{t-1})$ and $o_t   \\mathcal{O}(s_t)$. We run a set of simulations $\\{\\tau_i\\}_{i1}^m$ on small instances to collect data which is used as additional information to find an answer and identify strategies for a proof.\n\n\n\\subsection*{2024 IMO}\n\\label{appendix:H_2024_IMO}\n\n\n\\subsubsection*{Problem 3}\n\n\\hrule\n\\begin{lstlisting}[\nlanguagePython, basicstyle\\scriptsize\\ttfamily, numbersleft, breaklinestrue, breakatwhitespacetrue, xleftmargin2em, xrightmargin2em, aboveskip1em, belowskip1em,\ncaption{2024 IMO problem 3 game code.},\nlabel{listing:IMO2024P3}\n]\nimport gymnasium as gym\nfrom gymnasium import spaces\nimport pygame\nimport numpy as np\nfrom collections import deque\n\n\nclass IMOSequenceEnv(gym.Env):\n   metadata   {\"render_modes\": [\"human\"], \"render_fps\": 4}\n\n   def __init__(self, render_modeNone):\n   super().__init__()\n   self.render_mode   render_mode\n   self.sequence   deque(maxlenNone)\n   self.observation_space   spaces.Dict({\n   'sequence': spaces.Sequence(spaces.Box(low1, highMAX_INT, shape(), dtypenp.int32)),\n   'position': spaces.Discrete(MAX_INT)\n   })\n   self.action_space   spaces.Discrete(6)\n   self.window   None\n   self.clock   None\n   self.font   None\n   self.small_font   None\n   self.step_next   False\n   self.reset_requested   False\n   self.multi_step   False\n   self.scroll_offset   0\n   self.odd_period   None\n   self.even_period   None\n   self.odd_start   None\n   self.even_start   None\n\n   def reset(self, seedNone, optionsNone):\n   super().reset(seedseed)\n   self.sequence.clear()\n   self.sequence.append(self.np_random.integers(1, 4))\n   self.position   1\n   self.scroll_offset   0\n   self.odd_period   None\n   self.even_period   None\n   self.odd_start   None\n   self.even_start   None\n\n   observation   {'sequence': list(self.sequence), 'position': self.position}\n   if self.render_mode   \"human\":\n   self.render()\n   return observation, {}\n\n   def step(self, action):\n   if self.position > 2:\n   prev_element   self.sequence[self.position - 1]\n   count   sum(1 for x in list(self.sequence)[:self.position] if x   prev_element)\n   self.sequence.append(count)\n   else:\n   self.sequence.append(action)\n\n   self.position + 1\n   if self.position > MAX_VISIBLE_ELEMENTS + self.scroll_offset:\n   self.scroll_offset   self.position - MAX_VISIBLE_ELEMENTS\n\n   self._detect_periodicity()\n   reward   self._calculate_reward()\n\n   observation   {'sequence': list(self.sequence), 'position': self.position}\n   if self.render_mode   \"human\":\n   self.render()\n   return observation, reward, False, False, {}\n\n   def _detect_periodicity(self):\n   def find_repeating_pattern(seq):\n   if len(seq) < 10:\n   return None, None\n\n   for period in range(2, len(seq) // 3):\n   for start in range(len(seq) - 3 * period):\n   pattern   seq[start:start + period]\n   repetitions   0\n   pos   start\n   while pos + period < len(seq):\n   if seq[pos:pos + period]   pattern:\n   repetitions + 1\n   pos + period\n   else:\n   break\n   if repetitions > 3:\n   return period, start\n   return None, None\n\n   odd_seq   list(self.sequence)[1::2]\n   even_seq   list(self.sequence)[::2]\n\n   if self.odd_period is None:\n   self.odd_period, self.odd_start   find_repeating_pattern(odd_seq)\n\n   if self.even_period is None:\n   self.even_period, self.even_start   find_repeating_pattern(even_seq)\n\n   def _calculate_reward(self):\n   return 10 if (self.odd_period is not None or self.even_period is not None) else 0\n\n   def render(self):\n   if self.window is None:\n   pygame.init()\n   self.window   pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))\n   pygame.display.set_caption(\"IMO Sequence Visualization\")\n   self.clock   pygame.time.Clock()\n   self.font   pygame.font.SysFont('Arial', 24)\n   self.small_font   pygame.font.SysFont('Arial', 16)\n\n   self.window.fill(BACKGROUND_COLOR)\n\n   # Define layout sections\n   histogram_height   int(WINDOW_HEIGHT * 0.6)\n   sequences_height   int(WINDOW_HEIGHT * 0.25)\n   hist_x   100\n   hist_y   50\n\n   # Create frequency count dictionary and track positions\n   values   list(self.sequence)\n   if values:\n   value_counts   {}\n   positions   {}\n   max_val   max(values)\n\n   # First pass: count frequencies and store positions\n   for idx, val in enumerate(values):\n   if val not in value_counts:\n   value_counts[val]   []\n   positions[val]   []\n   value_counts[val].append(len(value_counts[val]))\n   positions[val].append(idx)\n\n   # Draw vertical stacks\n   cell_size   50\n   spacing   70\n   connections   []\n\n   # First draw all connections (behind the cells)\n   for val in range(1, max_val + 1):\n   if val in value_counts:\n   counts   value_counts[val]\n   x   hist_x + (val - 1) * spacing\n\n   for i, count in enumerate(counts):\n   y   histogram_height - (i + 1) * cell_size\n   sequence_pos   positions[val][i]\n\n   if sequence_pos < len(values) - 1:\n   next_val   values[sequence_pos + 1]\n   next_count   value_counts[next_val].index(len(value_counts[next_val]) - 1)\n   start_pos   (x + cell_size // 2, y + cell_size // 2)\n   end_pos   (hist_x + (next_val - 1) * spacing + cell_size // 2,\n   histogram_height - (next_count + 1) * cell_size + cell_size // 2)\n   # Draw connection line immediately\n   pygame.draw.line(self.window, CONNECTION_COLOR, start_pos, end_pos, 3)\n\n   # Then draw the cells (on top of the lines)\n   for val in range(1, max_val + 1):\n   if val in value_counts:\n   counts   value_counts[val]\n   x   hist_x + (val - 1) * spacing\n\n   for i, count in enumerate(counts):\n   y   histogram_height - (i + 1) * cell_size\n   sequence_pos   positions[val][i]\n\n   # Draw cell with orange background\n   rect   pygame.Rect(x, y, cell_size, cell_size)\n   pygame.draw.rect(self.window, CELL_BG_COLOR, rect)\n   pygame.draw.rect(self.window, AXIS_COLOR, rect, 1)\n\n   # Draw index number\n   text   self.small_font.render(str(sequence_pos), True, TEXT_COLOR)\n   text_rect   text.get_rect(center(x + cell_size // 2, y + cell_size // 2))\n   self.window.blit(text, text_rect)\n\n   # Draw x-axis\n   pygame.draw.line(self.window, AXIS_COLOR,\n   (hist_x - 20, histogram_height),\n   (hist_x + (max_val + 1) * spacing, histogram_height), 2)\n\n   # Draw x-axis labels\n   for val in range(1, max_val + 1):\n   x   hist_x + (val - 1) * spacing + cell_size // 2\n   text   self.font.render(str(val), True, TEXT_COLOR)\n   text_rect   text.get_rect(center(x, histogram_height + 25))\n   self.window.blit(text, text_rect)\n\n   # Draw sequence section\n   seq_start_y   histogram_height + 60\n   header_x   50\n\n   # Draw current sequence\n   for i in range(self.scroll_offset, min(self.position, self.scroll_offset + MAX_VISIBLE_ELEMENTS)):\n   x   header_x + (i - self.scroll_offset) * (CELL_SIZE + CELL_PADDING)\n   y   seq_start_y + 30\n\n   # Draw cell with orange background\n   pygame.draw.rect(self.window, CELL_BG_COLOR, (x, y, CELL_SIZE, CELL_SIZE))\n   pygame.draw.rect(self.window, AXIS_COLOR, (x, y, CELL_SIZE, CELL_SIZE), 1)\n\n   # Draw value\n   value_surface   self.small_font.render(str(self.sequence[i]), True, TEXT_COLOR)\n   value_rect   value_surface.get_rect(center(x + CELL_SIZE // 2, y + CELL_SIZE // 2))\n   self.window.blit(value_surface, value_rect)\n\n   # Draw index\n   index_surface   self.small_font.render(str(i), True, TEXT_COLOR)\n   index_rect   index_surface.get_rect(center(x + CELL_SIZE // 2, y - 15))\n   self.window.blit(index_surface, index_rect)\n\n   # Draw buttons\n   button_width   150\n   button_height   40\n   button_padding   20\n   buttons_y   WINDOW_HEIGHT - 60\n\n   start_x_buttons   (WINDOW_WIDTH - (3 * button_width + 2 * button_padding)) // 2\n\n   buttons   [\n   (\"Step\", (start_x_buttons, buttons_y, button_width, button_height), (0, 180, 0)),\n   (\"+10\", (start_x_buttons + button_width + button_padding, buttons_y, button_width, button_height),\n   (0, 140, 0)),\n   (\"Reset\", (start_x_buttons + 2 * (button_width + button_padding), buttons_y, button_width, button_height),\n   (180, 0, 0))\n   ]\n\n   for text, (x, y, w, h), color in buttons:\n   button_rect   pygame.Rect(x, y, w, h)\n   pygame.draw.rect(self.window, color, button_rect)\n   pygame.draw.rect(self.window, AXIS_COLOR, button_rect, 1)\n   text_surface   self.font.render(text, True, (255, 255, 255))\n   self.window.blit(text_surface, text_surface.get_rect(centerbutton_rect.center))\n\n   # Handle events\n   for event in pygame.event.get():\n   if event.type   pygame.QUIT:\n   pygame.quit()\n   quit()\n   elif event.type   pygame.MOUSEBUTTONDOWN:\n   x, y   event.pos\n   for text, (bx, by, bw, bh), _ in buttons:\n   if bx < x < bx + bw and by < y < by + bh:\n   if text   \"Step\":\n   self.step_next   True\n   elif text   \"+10\":\n   self.multi_step   True\n   elif text   \"Reset\":\n   self.reset_requested   True\n   break\n\n   pygame.display.flip()\n   self.clock.tick(self.metadata[\"render_fps\"])\n\n   def close(self):\n   if self.window is not None:\n   pygame.quit()\n   self.window   None\n\n\n\\end{lstlisting}\n\n\\newpage\n\\clearpage\n\n\\subsubsection*{Problem 5}\n\n\\hrule\n\\begin{lstlisting}[\nlanguagePython, basicstyle\\scriptsize\\ttfamily, numbersleft, breaklinestrue, breakatwhitespacetrue, xleftmargin2em, xrightmargin2em, aboveskip1em, belowskip1em,\ncaption{2024 IMO problem 5 game code.},\nlabel{listing:IMO2024P5}\n]\nimport gymnasium as gym\nfrom gymnasium import spaces\nimport numpy as np\nimport pygame\nimport time\n\n\nclass TurboSnailEnv(gym.Env):\n   metadata   {'render_modes': ['human'], 'render_fps': 4}\n\n   def __init__(self, grid_size(8, 7), render_modeNone):\n   super().__init__()\n   self.grid_rows, self.grid_cols   grid_size\n   self.render_mode   render_mode\n   self.action_space   spaces.Discrete(3)\n   self.observation_space   spaces.Box(\n   low-1.0,\n   high1.0,\n   shape(2 + self.grid_rows * self.grid_cols,),\n   dtypenp.float32\n   )\n\n   self.max_attempts   3\n   self.attempts   0\n   self._monster_positions   None\n   self._agent_position   None\n   self._grid_knowledge   None\n   self._current_attempt_over   False\n\n   self.window_size   800\n   if self.render_mode   'human':\n   pygame.init()\n   self.screen   pygame.display.set_mode((self.window_size - 88, self.window_size))\n   pygame.display.set_caption(\"Turbo the Snail\")\n   self.clock   pygame.time.Clock()\n   else:\n   self.screen   None\n   self.clock   None\n\n   self.reset()\n\n   def reset(self, seedNone, optionsNone):\n   super().reset(seedseed)\n   self.attempts   0\n   monster_rows   list(range(1, self.grid_rows - 1))\n   monster_cols   self.np_random.permutation(self.grid_cols)[:len(monster_rows)]\n\n   self._monster_positions   set(zip(monster_rows, monster_cols))\n   self._grid_knowledge   np.zeros((self.grid_rows, self.grid_cols), dtypenp.int8)\n   self._agent_position   (0, self.np_random.integers(0, self.grid_cols))\n   self._current_attempt_over   False\n\n   observation   self._get_obs()\n   info   self._get_info()\n\n   if self.render_mode   'human':\n   self.render()\n\n   return observation, info\n\n   def step(self, action):\n   row, col   self._agent_position\n   penalty   0.0   # Initialize penalty\n   if action   0:   # Down\n   row   min(self.grid_rows - 1, row + 1)\n   elif action   1:   # Left\n   col   max(0, col - 1)\n   elif action   2:   # Right\n   col   min(self.grid_cols - 1, col + 1)\n   elif action   3:   # Up\n   row   max(0, row - 1)\n   penalty   0.1\n   else:\n   raise ValueError(\"Invalid action\")\n\n   self._agent_position   (row, col)\n\n   terminated   False\n   reward   -0.01 - penalty   # Small negative reward per step plus penalty if moved up\n\n   # Check if agent encounters a monster\n   if self._agent_position in self._monster_positions:\n   self._grid_knowledge[row, col]   -1   # Mark as monster\n   self.attempts + 1   # Increment attempts\n   if self.attempts > self.max_attempts:\n   terminated   True\n   reward   -1.0   # Large negative reward for failing\n   else:\n   self._agent_position   (0, self.np_random.integers(0, self.grid_cols))   # Transport back to first row\n   reward - 0.1   # Additional negative reward for hitting a monster\n   else:\n   self._grid_knowledge[row, col]   1   # Mark as safe\n   if row   self.grid_rows - 1:\n   # Agent has reached the bottom row\n   reward   1.0 - 0.1 * self.attempts   # Positive reward, less per attempt\n   terminated   True\n\n   observation   self._get_obs()\n   info   self._get_info()\n\n   if self.render_mode   'human':\n   self.render()\n\n   return observation, reward, terminated, False, info\n\n   def _get_obs(self):\n   agent_row, agent_col   self._agent_position\n   # Normalize agent position to [0,1]\n   agent_pos   np.array([agent_row / (self.grid_rows - 1), agent_col / (self.grid_cols - 1)], dtypenp.float32)\n   # Flatten grid knowledge\n   grid_knowledge_flat   self._grid_knowledge.flatten().astype(np.float32)\n   return np.concatenate([agent_pos, grid_knowledge_flat])\n\n   def _get_info(self):\n   return {\n   'attempts': self.attempts\n   }\n\n   def render(self):\n   if self.screen is None:\n   return\n\n   cell_size   self.window_size // max(self.grid_rows, self.grid_cols)\n   self.screen.fill((30, 30, 30)) \n\n   # Draw grid lines\n   for x in range(self.grid_cols + 1):\n   pygame.draw.line(self.screen, (200, 200, 200), (x * cell_size, 0),\n   (x * cell_size, self.grid_rows * cell_size))\n   for y in range(self.grid_rows + 1):\n   pygame.draw.line(self.screen, (200, 200, 200), (0, y * cell_size),\n   (self.grid_cols * cell_size, y * cell_size))\n\n   # Draw known cells\n   for r in range(self.grid_rows):\n   for c in range(self.grid_cols):\n   rect   pygame.Rect(c * cell_size, r * cell_size, cell_size, cell_size)\n   if r   0 or r   self.grid_rows - 1:\n   pygame.draw.rect(self.screen, (60, 60, 60), rect)   # Dark grey for the first row\n   elif self._grid_knowledge[r, c]   1:\n   pygame.draw.rect(self.screen, (100, 200, 100), rect)   # Green for safe cells\n   elif self._grid_knowledge[r, c]   -1:\n   pygame.draw.rect(self.screen, (200, 100, 100), rect)   # Red for monster cells\n\n   # Draw labels for the starting and goal rows\n   font   pygame.font.Font(None, 36)\n   starting_label   font.render(\"Starting row\", True, (255, 255, 255))\n   goal_label   font.render(\"Goal row\", True, (255, 255, 255))\n   self.screen.blit(starting_label, ((self.window_size - 250)/2, 50))\n   self.screen.blit(goal_label, ((self.window_size - 220)/2, (self.grid_rows - 1) * cell_size + 50))\n\n   # Draw agent\n   agent_rect   pygame.Rect(\n   self._agent_position[1] * cell_size,\n   self._agent_position[0] * cell_size,\n   cell_size,\n   cell_size\n   )\n   pygame.draw.rect(self.screen, (100, 100, 250), agent_rect)   # Blue for agent\n\n   # Update the display\n   pygame.display.flip()\n   self.clock.tick(self.metadata['render_fps'])\n\n   def close(self):\n   if self.screen is not None:\n   pygame.quit()\n   self.screen   None\n\\end{lstlisting}\n\n\n\\newpage\n\n\\subsection*{2024 USAMO}\n\\label{appendix:H_2024_USAMO}\n\n\\subsubsection*{Problem 2}\n\n\\hrule\n\\begin{lstlisting}[\nlanguagePython, basicstyle\\scriptsize\\ttfamily, numbersleft, breaklinestrue, breakatwhitespacetrue, xleftmargin2em, xrightmargin2em, aboveskip1em, belowskip1em,\ncaption{USAMO 2024 problem 2 game code.},\nlabel{listing:USAMO2024C2}\n]\nimport gymnasium as gym\nimport numpy as np\nfrom gymnasium import spaces\nfrom typing import Optional, Tuple, Dict, Any\nimport pygame\nimport math\n\nclass SetsEnvironment(gym.Env):\n   \"\"\"\n   A Gymnasium environment for the sets intersection problem with Pygame visualization.\n   The threshold for counting elements is dynamically set to half of the total sets.\n   \"\"\"\n   \n   def __init__(self, num_sets: int   100, max_elements: int   1000, render_mode: str   \"pygame\"):\n   super().__init__()\n   \n   self.num_sets   num_sets\n   self.max_elements   max_elements\n   self.render_mode   render_mode\n   self.threshold   num_sets // 2   # New threshold based on half the number of sets\n   \n   # Action space: (set_idx, element_idx, action_type)\n   # action_type: 0   remove, 1   add\n   self.action_space   spaces.MultiDiscrete([\n   num_sets,   # Which set to modify\n   max_elements,   # Which element to add/remove\n   2   # Add or remove action\n   ])\n   \n   # Observation space: binary matrix of shape (max_elements, num_sets)\n   self.observation_space   spaces.Box(\n   low0,\n   high1,\n   shape(max_elements, num_sets),\n   dtypenp.int8\n   )\n   \n   self.state   None\n   self.steps   0\n   self.max_steps   10000\n   self.best_valid_score   float('inf')   # Track best valid solution\n   \n   # Pygame visualization setup\n   if self.render_mode   \"pygame\":\n   pygame.init()\n   self.window_size   (1200, 800)\n   self.screen   pygame.display.set_mode(self.window_size)\n   pygame.display.set_caption(f\"Sets Intersection Visualization (Threshold: {self.threshold} sets)\")\n   self.clock   pygame.time.Clock()\n   self.font   pygame.font.Font(None, 24)\n   \n   # Colors\n   self.colors   [\n   (255, 0, 0), (0, 255, 0), (0, 0, 255),\n   (255, 255, 0), (255, 0, 255), (0, 255, 255),\n   (128, 0, 0), (0, 128, 0), (0, 0, 128),\n   (128, 128, 0)\n   ] * 10   # Repeat colors for more sets\n   \n   def reset(self, seed: Optional[int]   None, options: Optional[Dict]   None) -> Tuple[np.ndarray, Dict[str, Any]]:\n   super().reset(seedseed)\n   \n   # Initialize with one element in all sets to ensure non-empty intersection\n   self.state   np.zeros((self.max_elements, self.num_sets), dtypenp.int8)\n   self.state[0]   1   # First element belongs to all sets\n   \n   self.steps   0\n   self.best_valid_score   float('inf')\n   \n   if self.render_mode   \"pygame\":\n   self._render_frame()\n   \n   return self.state, {}\n   \n   def _check_constraints(self) -> bool:\n   \"\"\"Check if current state satisfies all constraints.\"\"\"\n   # Get all possible subsets of sets (using binary representation)\n   for subset_mask in range(1, 2**self.num_sets):\n   # Convert to binary array\n   subset   np.array([int(x) for x in format(subset_mask, f'0{self.num_sets}b')])\n   num_sets_in_subset   np.sum(subset)\n   \n   # Get elements in intersection of these sets\n   intersection_size   np.sum(np.all(self.state[:, subset   1]   1, axis1))\n   \n   # Check if intersection size is multiple of number of sets\n   if intersection_size   num_sets_in_subset ! 0:\n   return False\n   \n   # Check if intersection is non-empty when all sets are selected\n   if subset_mask   2**self.num_sets - 1 and intersection_size   0:\n   return False\n   \n   return True\n   \n   def _get_reward(self) -> float:\n   \"\"\"Calculate reward based on number of elements in threshold or more sets.\"\"\"\n   elements_above_threshold   np.sum(np.sum(self.state, axis1) > self.threshold)\n   return -elements_above_threshold   # Negative because we want to minimize\n   \n   def step(self, action: np.ndarray) -> Tuple[np.ndarray, float, bool, bool, Dict[str, Any]]:\n   self.steps + 1\n   \n   set_idx, element_idx, action_type   action\n   \n   # Apply action directly without reverting\n   self.state[element_idx, set_idx]   action_type\n   \n   # Calculate reward\n   reward   self._get_reward()\n   \n   # Check if current state is valid\n   is_valid   self._check_constraints()\n   \n   if is_valid:\n   # Update best valid score if current solution is better\n   current_score   -reward   # Convert negative reward to positive score\n   if current_score < self.best_valid_score:\n   self.best_valid_score   current_score\n   reward + 1000   # Bonus for finding better solution\n   else:\n   reward - 10   # Small penalty for invalid states to encourage finding valid ones\n   \n   # Terminate if we find a valid solution\n   # Note: You might want to continue searching for better solutions\n   terminated   (is_valid and self.steps > 1000) or self.steps > self.max_steps\n   truncated   False\n   \n   if self.render_mode   \"pygame\":\n   self._render_frame()\n   \n   info   {\n   'is_valid': is_valid,\n   'best_valid_score': self.best_valid_score if self.best_valid_score ! float('inf') else None\n   }\n   \n   return self.state, reward, terminated, truncated, info\n   \n   def _render_frame(self):\n   \"\"\"Render the current state using Pygame.\"\"\"\n   if self.render_mode ! \"pygame\":\n   return\n   \n   self.screen.fill((255, 255, 255))   # White background\n   \n   # Calculate visualization parameters\n   active_elements   np.sum(self.state, axis1) > 0\n   num_active_elements   np.sum(active_elements)\n   elements_above_threshold   np.sum(np.sum(self.state, axis1) > self.threshold)\n   is_valid   self._check_constraints()\n   \n   # Draw sets as circles\n   center_x   self.window_size[0] // 2\n   center_y   self.window_size[1] // 2\n   max_radius   min(self.window_size[0], self.window_size[1]) * 0.4\n   \n   visible_sets   min(10, self.num_sets)\n\n   # Draw elements in a grid layout\n   element_radius   3\n   grid_spacing   10\n   elements_per_row   20\n   margin_left   500\n   margin_top   300\n   \n   # Draw active elements\n   for elem_idx in range(self.max_elements):\n   if np.sum(self.state[elem_idx]) > 0:   # If element is in any set\n   sets_containing   np.where(self.state[elem_idx]   1)[0]\n   \n   # Calculate grid position\n   row   (elem_idx // elements_per_row)\n   col   elem_idx   elements_per_row\n   x   margin_left + col * grid_spacing\n   y   margin_top + row * grid_spacing\n   \n   # Color based on threshold\n   if len(sets_containing) > self.threshold:\n   color   (255, 0, 0)   # Red for elements above threshold\n   else:\n   color   (0, 0, 0)   # Black for other elements\n   \n   # Draw lines to sets (only for first few elements to avoid clutter)\n   if elem_idx < 20:   # Limit connections to first 20 elements\n   for set_idx in sets_containing[:visible_sets]:\n   angle   2 * math.pi * set_idx / visible_sets\n   set_x   center_x + max_radius * math.cos(angle)\n   set_y   center_y + max_radius * math.sin(angle)\n   pygame.draw.line(self.screen, (200, 200, 200), (x, y), (int(set_x), int(set_y)), 3)\n\n   # Draw element\n   pygame.draw.circle(self.screen, color, (x, y), element_radius)   \n   \n   # Draw sets (first 10 sets for visibility)\n   for i in range(visible_sets):\n   angle   2 * math.pi * i / visible_sets\n   x   center_x + max_radius * math.cos(angle)\n   y   center_y + max_radius * math.sin(angle)\n   \n   # Draw set circle\n   pygame.draw.circle(self.screen, self.colors[i], (int(x), int(y)), 50, 5)\n   \n   # Draw set label\n   text   self.font.render(f\"Set {i+1}\", True, self.colors[i])\n   self.screen.blit(text, (int(x) - 20, int(y) - 30))\n\n\n   # Draw statistics\n   stats   [\n   f\"Step: {self.steps}/{self.max_steps}\",\n   f\"Active Elements: {num_active_elements}\",\n   f\"Elements in {self.threshold}+ sets: {elements_above_threshold}\",\n   f\"Valid Solution: {'Yes' if is_valid else 'No'}\",\n   f\"Best Valid Score: {self.best_valid_score if self.best_valid_score ! float('inf') else 'None'}\",\n   ]\n   \n   for i, text in enumerate(stats):\n   surface   self.font.render(text, True, (0, 0, 0))\n   self.screen.blit(surface, (10, 10 + i * 30))\n   \n   pygame.display.flip()\n   self.clock.tick(30)\n   \n   def render(self):\n   \"\"\"Render the environment.\"\"\"\n   if self.render_mode   \"pygame\":\n   self._render_frame()\n   else:\n   # Print text-based statistics\n   elements_in_sets   np.sum(self.state, axis1)\n   elements_above_threshold   np.sum(elements_in_sets > self.threshold)\n   print(f\"Elements in {self.threshold}+ sets: {elements_above_threshold}\")\n   print(f\"Step: {self.steps}/{self.max_steps}\")\n   print(f\"Best Valid Score: {self.best_valid_score if self.best_valid_score ! float('inf') else 'None'}\")\n   \n   def close(self):\n   \"\"\"Close the environment.\"\"\"\n   if self.render_mode   \"pygame\":\n   pygame.quit()\n\n# Example usage\nif __name__   \"__main__\":\n   # Example with different number of sets\n   num_sets   6   # Try with different numbers of sets\n   max_elements   50\n   env   SetsEnvironment(num_setsnum_sets, max_elements   max_elements, render_mode\"pygame\")\n   obs, _   env.reset()\n   \n   running   True\n   while running:\n   # Handle Pygame events\n   for event in pygame.event.get():\n   if event.type   pygame.QUIT:\n   running   False\n   \n   # Random agent example\n   action   env.action_space.sample()\n   obs, reward, terminated, truncated, info   env.step(action)\n   \n   if terminated or truncated:\n   obs, _   env.reset()\n   \n   env.close()\n\n\\end{lstlisting}\n\n\\newpage\n\\clearpage\n\n\\subsubsection*{Problem 4}\n\n\\hrule\n\\begin{lstlisting}[\nlanguagePython, basicstyle\\scriptsize\\ttfamily, numbersleft, breaklinestrue, breakatwhitespacetrue, xleftmargin2em, xrightmargin2em, aboveskip1em, belowskip1em,\ncaption{USAMO 2024 problem 4 game code.},\nlabel{listing:USAMO2024C4}\n]\n\nimport pygame\nimport numpy as np\nimport gymnasium as gym\nfrom gymnasium import spaces\nfrom datetime import datetime\n\n# Colors\nWHITE   (255, 255, 255)\nBLACK   (0, 0, 0)\nRED   (255, 0, 0)\nBLUE   (0, 0, 255)\nGRAY   (200, 200, 200)\nGREEN   (0, 255, 0)\n\n# Screen settings\nWIDTH, HEIGHT   600, 800\nCELL_SIZE   143\nMARGIN   5\nFPS   30\n\n\nclass BeadsGame(gym.Env):\n   def __init__(self, initial_m4, initial_n4, max_blocks10):\n   super().__init__()\n   self.max_blocks   max_blocks\n   self.m   initial_m\n   self.n   initial_n\n\n   # Gymnasium action and observation spaces\n   self.action_space   spaces.MultiDiscrete([2] * (self.m * self.n))\n   self.observation_space   spaces.Box(\n   low0, high1,\n   shape(self.m, self.n),\n   dtypenp.int32\n   )\n\n   # Pygame setup\n   pygame.init()\n   self.screen   pygame.display.set_mode((WIDTH, HEIGHT))\n   pygame.display.set_caption(\"Beads Game\")\n   self.clock   pygame.time.Clock()\n   self.font   pygame.font.SysFont(\"Arial\", 20)\n\n   # Track successful solutions\n   self.solutions   set()\n   self.solutions_file   f\"beads_solutions_{datetime.now().strftime('Ymd_HMS')}.txt\"\n\n   # Game state\n   self.reset()\n\n   def reset(self, seedNone, optionsNone):\n   super().reset(seedseed)\n   self.grid   np.zeros((self.m, self.n), dtypeint)\n   self.valid   False\n   self.score   0\n   return self.grid, {}\n\n   def check_constraints(self):\n   \"\"\"\n   Check if each possible circular cut of the necklace has unique red bead counts.\n   Checks that for each start position, the rows have distinct red bead counts.\n   \"\"\"\n   # Manually extend the grid by copying the next row to the right, and for the last row, wrap around to the first row\n   extended_grid   np.zeros((self.m, 2 * self.n), dtypeint)   # Create an extended grid\n\n   for row in range(self.m):\n   # Copy the current row to the first part of the extended grid\n   extended_grid[row, :self.n]   self.grid[row]\n\n   # Copy the next row to the second part (wrap around for the last row)\n   extended_grid[row, self.n:]   self.grid[(row + 1)   self.m]\n\n   # For each possible start position\n   for start in range(self.n):\n   # Collect red bead counts for this circular cut\n   row_counts   [np.sum(extended_grid[row, start:start + self.n]) for row in range(self.m)]\n\n   # Check if all counts in this cut are unique\n   if len(set(row_counts)) ! self.m:\n   return False\n\n   return True\n\n   def calculate_score(self):\n   \"\"\"Calculate the score based on grid validity and bead count.\"\"\"\n   return self.m * self.n if self.check_constraints() else -1\n\n   def update_solutions(self):\n   \"\"\"Automatically track valid solutions.\"\"\"\n   if self.check_constraints():\n   self.solutions.add((self.n, self.m))\n\n   def save_solutions_to_file(self):\n   \"\"\"Write all collected solutions to file as tuples.\"\"\"\n   if len(self.solutions) > 0:\n   sorted_solutions   sorted(list(self.solutions))\n   with open(self.solutions_file, 'w') as f:\n   solution_strings   [f\"({n},{m})\" for n, m in sorted_solutions]\n   f.write(\" ; \".join(solution_strings))\n   print(f\"Solutions saved to {self.solutions_file}\")\n\n   def step(self, action):\n   # Convert action to grid update\n   action_grid   np.array(action).reshape(self.m, self.n)\n   self.grid   action_grid\n\n   # Check game constraints and update solutions\n   self.valid   self.check_constraints()\n   self.score   self.calculate_score()\n   self.update_solutions()\n\n   # Determine if game is done\n   done   self.valid\n\n   return self.grid, self.score, done, False, {}\n\n   def render(self):\n   self.screen.fill(WHITE)\n\n   # Draw grid\n   for row in range(self.m):\n   for col in range(self.n):\n   color   RED if self.grid[row][col]   1 else BLUE\n   pygame.draw.rect(self.screen, color, [\n   col * (CELL_SIZE + MARGIN) + MARGIN,\n   row * (CELL_SIZE + MARGIN) + MARGIN,\n   CELL_SIZE,\n   CELL_SIZE\n   ])\n   pygame.draw.rect(self.screen, GRAY, [\n   col * (CELL_SIZE + MARGIN) + MARGIN,\n   row * (CELL_SIZE + MARGIN) + MARGIN,\n   CELL_SIZE,\n   CELL_SIZE\n   ], 1)\n\n   # Display current m and n\n   m_text   self.font.render(f\"Rows (m): {self.m}\", True, BLACK)\n   n_text   self.font.render(f\"Columns (n): {self.n}\", True, BLACK)\n   # self.screen.blit(m_text, (WIDTH - 200, 10))\n   # self.screen.blit(n_text, (WIDTH - 200, 40))\n   self.screen.blit(m_text, (WIDTH - 200, HEIGHT - 140))\n   self.screen.blit(n_text, (WIDTH - 200, HEIGHT - 110))\n\n   # Display solutions count\n   solutions_text   self.font.render(f\"Solutions found: {len(self.solutions)}\", True, BLACK)\n   self.screen.blit(solutions_text, (WIDTH - 200, HEIGHT - 30))\n\n   # Display real-time score and status\n   score_text   self.font.render(f\"Score: {self.calculate_score()}\", True, BLACK)\n   self.screen.blit(score_text, (WIDTH - 200, HEIGHT - 70))\n\n   if self.check_constraints():\n   status_text   self.font.render(\"Valid Configuration!\", True, GREEN)\n   else:\n   status_text   self.font.render(\"Invalid Configuration\", True, RED)\n   self.screen.blit(status_text, (WIDTH // 2 - 100, HEIGHT - 40))\n\n   # Display controls\n   controls_text1   self.font.render(\"Q/A: Change m   |   W/S: Change n\", True, BLACK)\n   controls_text2   self.font.render(\"R: Reset   |   ESC: Quit\", True, BLACK)\n   self.screen.blit(controls_text1, (10, HEIGHT - 140))\n   self.screen.blit(controls_text2, (10, HEIGHT - 110))\n\n   pygame.display.flip()\n   self.clock.tick(FPS)\n\n   def close(self):\n   self.save_solutions_to_file()\n   pygame.quit()\n\n\ndef interactive_play():\n   env   BeadsGame()\n\n   running   True\n   while running:\n   env.render()\n\n   for event in pygame.event.get():\n   if event.type   pygame.QUIT:\n   running   False\n   elif event.type   pygame.MOUSEBUTTONDOWN:\n   x, y   pygame.mouse.get_pos()\n   col   x // (CELL_SIZE + MARGIN)\n   row   y // (CELL_SIZE + MARGIN)\n   if 0 < row < env.m and 0 < col < env.n:\n   env.grid[row][col]   1 - env.grid[row][col]\n   env.update_solutions()   # Check for valid solution after each move\n   elif event.type   pygame.KEYDOWN:\n   # Controls for m and n\n   if event.key   pygame.K_q and env.m > 1:\n   env.m - 1\n   env.reset()\n   elif event.key   pygame.K_a:\n   env.m + 1\n   env.reset()\n   elif event.key   pygame.K_w and env.n > 1:\n   env.n - 1\n   env.reset()\n   elif event.key   pygame.K_s:\n   env.n + 1\n   env.reset()\n\n   # Reset game\n   elif event.key   pygame.K_r:\n   env.reset()\n\n   # Quit game\n   elif event.key   pygame.K_ESCAPE:\n   running   False\n\n   env.close()\n\n\nif __name__   \"__main__\":\n   interactive_play()\n\n\n\\end{lstlisting}\n\n\n\\newpage\n\\clearpage\n\n\n\\subsection*{2023 IMO Shortlist}\n\\label{appendix:H_2023_IMO_Shortlist}\n\n\\subsubsection*{Problem 1}\n\\label{appendix:H_2023_IMO_Shortlist_C1}\n\n\\hrule\n\\begin{lstlisting}[\nlanguagePython, basicstyle\\scriptsize\\ttfamily, numbersleft, breaklinestrue, breakatwhitespacetrue, xleftmargin2em, xrightmargin2em, aboveskip1em, belowskip1em,\ncaption{IMO 2023 Shortlist problem 1 game code.},\nlabel{listing:IMO2023SLC1}\n]\nimport time\n\nimport numpy as np\nimport pygame\nimport gymnasium as gym\nfrom gymnasium import spaces\n\nclass CoinFlipGridEnv(gym.Env):\n   \"\"\"\n   Custom Gymnasium environment for the coin flipping problem.\n   The agent aims to flip all coins to head-side up (1),\n   using moves defined in the problem description.\n   \"\"\"\n   metadata   {'render_modes': ['human', 'rgb_array'], 'render_fps': 10}\n\n   def __init__(self, m4, n4, render_modeNone):\n   super().__init__()\n   self.coin_choice   0\n\n   self.m   m   # number of rows\n   self.n   n   # number of columns\n   self.size   (self.m, self.n)\n   self.render_mode   render_mode\n\n   # Maximum window size\n   self.max_window_size   800   # Maximum size of the PyGame window (adjust as needed)\n   self.text_height   70   # Height reserved for text and buttons at the top\n\n   # Compute cell size and window dimensions dynamically based on m and n\n   self.cell_size   min((self.max_window_size - self.text_height) // self.m, (self.max_window_size) // self.n)\n   self.window_width   self.n * self.cell_size\n   self.window_height   self.m * self.cell_size + self.text_height   # Add space for text\n\n   # Observation space: the state of the grid (flattened)\n   self.observation_space   spaces.Box(0, 1, shape(self.m * self.n,), dtypeint)\n\n   # Action space: selecting a 2x2 square and choosing which coin to flip\n   # Total actions   2 * (m-1)*(n-1)\n   self.num_actions   2 * (self.m - 1) * (self.n - 1)\n   self.action_space   spaces.Discrete(self.num_actions)\n\n   # PyGame variables\n   self.window   None\n   self.clock   None\n\n   # Initialize the state\n   self.state   np.zeros((self.m, self.n), dtypeint)\n\n   # Variables for highlighting\n   self.last_action   None   # To store the last action taken\n   self.flipped_coins   []   # To store the positions of flipped coins\n\n   # For the \"Reset\" button\n   self.button_rect   pygame.Rect(self.window_width - 100, 10, 80, 30)\n\n   def reset(self, seedNone, optionsNone):\n   super().reset(seedseed)\n   self.state   np.zeros((self.m, self.n), dtypeint)\n   self.last_action   None\n   self.flipped_coins   []\n   if self.render_mode   \"human\" and self.window is not None:\n   self.window.fill((255, 255, 255))\n   pygame.display.flip()\n   return self.state.flatten(), {}\n\n   def step(self, action):\n   total_squares   (self.m - 1) * (self.n - 1)\n   if action < total_squares * 2:\n   square_index   action // 2\n   coin_choice   action   2   # 0: flip top-right; 1: flip bottom-left\n\n   i   square_index // (self.n - 1)\n   j   square_index   (self.n - 1)\n\n   self._perform_move(i, j, coin_choice)\n   self.last_action   (i, j, coin_choice)   # Store the last action for highlighting\n   else:\n   raise ValueError(\"Invalid action.\")\n\n   done   np.all(self.state   1)\n   reward   1 if done else -0.01\n\n   return self.state.flatten(), reward, done, False, {}\n\n   def _perform_move(self, i, j, coin_choice):\n   self.flipped_coins   []\n\n   self.state[i, j] ^ 1   # Flip top-left\n   self.flipped_coins.append((i, j))\n\n   self.state[i+1, j+1] ^ 1   # Flip bottom-right\n   self.flipped_coins.append((i+1, j+1))\n\n   if coin_choice   0:\n   self.state[i, j+1] ^ 1   # Flip top-right\n   self.flipped_coins.append((i, j+1))\n   else:\n   self.state[i+1, j] ^ 1   # Flip bottom-left\n   self.flipped_coins.append((i+1, j))\n\n   def calculate_T_values(self):\n   T   [0, 0, 0]\n   for i in range(self.m):\n   for j in range(self.n):\n   label   (i + j)   3   # Zero-based indexing\n   if self.state[i, j]   1:   # Coin is head-side up\n   T[label] + 1\n   return T\n\n   def check_invariant(self):\n   T   self.calculate_T_values()\n   parity   [T[i]   2 for i in range(3)]\n   return parity.count(parity[0])   3   # Returns True if all parities are equal\n\n   def render(self):\n   if self.render_mode   \"human\":\n   if self.window is None:\n   pygame.init()\n   pygame.display.init()\n   self.window   pygame.display.set_mode((self.window_width, self.window_height))\n   self.clock   pygame.time.Clock()\n   self._render_frame()\n   self.clock.tick(self.metadata[\"render_fps\"])\n   elif self.render_mode   \"rgb_array\":\n   return self._render_frame()\n\n   def _render_frame(self):\n   if self.window is None:\n   pygame.init()\n   pygame.display.init()\n   self.window   pygame.Surface((self.window_width, self.window_height))\n\n   self.window.fill((255, 255, 255))\n\n   # Draw the coin_choice indicator\n   font   pygame.font.SysFont(None, 24)\n   coin_choice_text   f\"Coin choice: {self.coin_choice} ({'top-right' if self.coin_choice   0 else 'bottom-left'})\"\n   text   font.render(coin_choice_text, True, (0, 0, 0))\n   self.window.blit(text, (10, 10))\n\n   # Draw the \"Reset\" button\n   pygame.draw.rect(self.window, (0, 128, 0), self.button_rect)   # Green button\n   text   font.render('Reset', True, (255, 255, 255))\n   text_rect   text.get_rect(centerself.button_rect.center)\n   self.window.blit(text, text_rect)\n\n   # Calculate T values and check invariant\n   T   self.calculate_T_values()\n   invariant_holds   self.check_invariant()\n\n   # Display T(0), T(1), T(2)\n   T_text   f\"T(0): {T[0]}, T(1): {T[1]}, T(2): {T[2]}\"\n   T_surface   font.render(T_text, True, (0, 0, 0))\n   self.window.blit(T_surface, (10, 35))\n\n   # Display invariant status\n   invariant_text   f\"Invariant holds: {invariant_holds}\"\n   invariant_surface   font.render(invariant_text, True, (0, 0, 0))\n   self.window.blit(invariant_surface, (200, 35))\n\n   # Draw the grid and coins\n   for i in range(self.m):\n   for j in range(self.n):\n   rect   pygame.Rect(\n   j * self.cell_size,\n   i * self.cell_size + self.text_height,   # Adjust for the coin_choice text\n   self.cell_size,\n   self.cell_size\n   )\n   pygame.draw.rect(self.window, (0, 0, 0), rect, 1)\n\n   # Draw coin\n   if self.state[i, j]   0:\n   pygame.draw.circle(\n   self.window,\n   (128, 128, 128),\n   rect.center,\n   self.cell_size // 2 - 5\n   )\n   else:\n   pygame.draw.circle(\n   self.window,\n   (255, 223, 0),\n   rect.center,\n   self.cell_size // 2 - 5\n   )\n\n   # Calculate the label\n   label   i + j + 1 # (i + j)   3   # 1-n and 1-m\n   #label   (i + j)   3   # Zero-based indexing\n   label_text   str(label)\n   label_surface   font.render(label_text, True, (0, 0, 0))\n   label_rect   label_surface.get_rect(\n   center(rect.x + self.cell_size // 2, rect.y + self.cell_size // 2)\n   )\n   # self.window.blit(label_surface, label_rect)\n\n   # Highlight the last selected 2x2 square and flipped coins\n   if self.last_action is not None:\n   i, j, _   self.last_action\n   highlight_rect   pygame.Rect(\n   j * self.cell_size,\n   i * self.cell_size + self.text_height,\n   self.cell_size * 2,\n   self.cell_size * 2\n   )\n   pygame.draw.rect(self.window, (255, 0, 0), highlight_rect, 3)   # Red border\n\n   for (fi, fj) in self.flipped_coins:\n   padding   4\n   rect   pygame.Rect(\n   fj * self.cell_size + padding,\n   fi * self.cell_size + self.text_height + padding,\n   self.cell_size - 2 * padding,\n   self.cell_size - 2 * padding\n   )\n   pygame.draw.rect(self.window, (0, 255, 0), rect, 3)   # Green border\n\n   if self.render_mode   \"human\":\n   pygame.display.get_surface().blit(self.window, (0, 0))\n   pygame.display.flip()\n   else:\n   return np.array(pygame.surfarray.array3d(self.window))\n\n   def close(self):\n   if self.window is not None:\n   pygame.display.quit()\n   pygame.quit()\n   self.window   None\n   self.clock   None\n   \n\\end{lstlisting}\n\n\n\\newpage\n\\clearpage\n\n\\subsubsection*{Problem 2}\n\\label{appendix:G_2023_IMO_Shortlist_C2}\n\n\\hrule\n\\begin{lstlisting}[\nlanguagePython, basicstyle\\scriptsize\\ttfamily, numbersleft, breaklinestrue, breakatwhitespacetrue, xleftmargin2em, xrightmargin2em, aboveskip1em, belowskip1em,\ncaption{IMO 2023 Shortlist problem 2 game code.},\nlabel{listing:IMO2024SLC2}\n]\nimport gymnasium as gym\nfrom gymnasium import spaces\nimport numpy as np\nfrom itertools import product\nimport pygame\nimport sys\nimport csv\nfrom dataclasses import dataclass\nfrom typing import Optional, Dict, Any, List, Tuple\n\n@dataclass\nclass SequenceRecord:\n   sequence: List[int]\n   score: float\n   k: int\n\nclass SequenceGameEnv(gym.Env):\n   def __init__(self, initial_k: int   10, human_play: bool   True):\n   super(SequenceGameEnv, self).__init__()\n   \n   self.human_play   human_play\n   self.k   initial_k\n   self.sequence   []\n   self.max_length   100\n   \n   # History tracking\n   self.submission_history: List[SequenceRecord]   []\n   self.best_submission: Optional[SequenceRecord]   None\n   \n   # Action space includes numbers 1 to k and 'submit' action\n   self.action_space   spaces.Discrete(self.k + 1)\n   \n   self.observation_space   spaces.Dict({\n   \"sequence\": spaces.Box(low1, highself.k, shape(self.max_length,), dtypenp.int64),\n   \"length\": spaces.Discrete(self.max_length),\n   \"k\": spaces.Box(low1, highnp.inf, shape(1,), dtypenp.int64)\n   })\n   \n   self.reset()\n\n   def set_k(self, new_k: int) -> None:\n   self.k   new_k\n   self.action_space   spaces.Discrete(self.k + 1)\n\n   def reset(self, k: Optional[int]   None) -> tuple[Dict, Dict]:\n   if k is not None:\n   self.set_k(k)\n   \n   self.sequence   []\n   \n   observation   {\n   \"sequence\": np.array(self.sequence),\n   \"length\": len(self.sequence),\n   \"k\": np.array([self.k])\n   }\n   return observation, {}\n\n   def step(self, action: int) -> tuple[Dict, float, bool, bool, Dict]:\n   done   False\n   reward   0\n   \n   # Handle submit action\n   if action   self.k:   # Submit action\n   if len(self.sequence) > 0:\n   if self._is_valid_sequence():\n   reward   len(self.sequence)\n   # Record submission\n   record   SequenceRecord(\n   sequenceself.sequence.copy(),\n   scorereward,\n   kself.k\n   )\n   self.submission_history.append(record)\n   \n   # Update best submission\n   if (self.best_submission is None or \n   reward > self.best_submission.score):\n   self.best_submission   record\n   else:\n   reward   -1\n   # Reset sequence after submission but don't end game\n   self.sequence   []\n   else:\n   reward   0\n   \n   # Handle number actions\n   elif 0 < action < self.k:\n   self.sequence.append(action)\n   if len(self.sequence) > self.max_length:\n   done   True\n   reward   -1 if not self._is_valid_sequence() else len(self.sequence)\n\n   observation   {\n   \"sequence\": np.array(self.sequence),\n   \"length\": len(self.sequence),\n   \"k\": np.array([self.k])\n   }   \n   return observation, reward, done, False, {}\n\n   def _is_valid_sequence(self) -> bool:\n   for i in range(len(self.sequence)):\n   for j in range(i + 1, len(self.sequence) + 1):\n   sub_seq   self.sequence[i:j]\n   for s in product([1, -1], repeatlen(sub_seq)):\n   if np.dot(sub_seq, s)   0:\n   return False\n   return True\n   \n   def export_best_result(self, filename: str   \"best_sequence.csv\"):\n   if self.best_submission:\n   with open(filename, 'w', newline'') as f:\n   writer   csv.writer(f)\n   writer.writerow(['k', 'best_list', 'length'])\n   writer.writerow([\n   self.best_submission.k,\n   ','.join(map(str, self.best_submission.sequence)),\n   len(self.best_submission.sequence)\n   ])\n\nclass SequenceGameGUI:\n   def __init__(self, env: SequenceGameEnv):\n   pygame.init()\n   self.env   env\n   self.WIDTH, self.HEIGHT   800, 600\n   self.screen   pygame.display.set_mode((self.WIDTH, self.HEIGHT))\n   pygame.display.set_caption(\"Sequence Game\")\n   self.font   pygame.font.Font(None, 32)\n   \n   # Button settings\n   self.button_width   60\n   self.button_height   40\n   self.button_margin   10\n   self.number_button_color   (0, 0, 255)\n   self.button_hover_color   (0, 100, 255)\n   \n   # Control button colors\n   self.submit_button_color   (0, 255, 0)\n   self.quit_button_color   (255, 0, 0)\n   self.reset_button_color   (255, 165, 0)\n   \n   # Scroll settings\n   self.scroll_x   0\n   self.scroll_speed   20\n   self.buttons_area_width   self.WIDTH - 120\n   \n   # Button rectangles\n   self.submit_button   pygame.Rect(10, 120, 100, 40)\n   self.quit_button   pygame.Rect(120, 120, 100, 40)\n   self.reset_button   pygame.Rect(10, self.HEIGHT - 50, 100, 40)\n   \n   # K input settings\n   self.k_input   \"\"\n   self.k_input_active   False\n   self.k_input_rect   pygame.Rect(120, self.HEIGHT - 50, 100, 40)\n   \n   # Tooltip settings\n   self.hover_text   \"\"\n   self.hover_pos   (0, 0)\n\n   def draw_buttons(self):\n   total_width   self.env.k * (self.button_width + self.button_margin)\n   \n   # Draw scroll arrows if needed\n   if total_width > self.buttons_area_width:\n   left_arrow   pygame.Rect(0, 60, 30, self.button_height)\n   pygame.draw.rect(self.screen, (150, 150, 150), left_arrow)\n   if left_arrow.collidepoint(pygame.mouse.get_pos()):\n   self.scroll_x   min(0, self.scroll_x + self.scroll_speed)\n   \n   right_arrow   pygame.Rect(self.WIDTH - 30, 60, 30, self.button_height)\n   pygame.draw.rect(self.screen, (150, 150, 150), right_arrow)\n   if right_arrow.collidepoint(pygame.mouse.get_pos()):\n   self.scroll_x   max(-(total_width - self.buttons_area_width), \n   self.scroll_x - self.scroll_speed)\n   \n   # Create number buttons surface\n   buttons_surface   pygame.Surface((total_width, self.button_height))\n   buttons_surface.fill((255, 255, 255))\n   \n   mouse_pos   pygame.mouse.get_pos()\n   \n   # Draw number buttons\n   self.hover_text   \"\"\n   for i in range(1, self.env.k + 1):\n   x   (i-1) * (self.button_width + self.button_margin)\n   button_rect   pygame.Rect(x, 0, self.button_width, self.button_height)\n   \n   screen_rect   pygame.Rect(x + 30 + self.scroll_x, 60, \n   self.button_width, self.button_height)\n   if screen_rect.collidepoint(mouse_pos):\n   pygame.draw.rect(buttons_surface, self.button_hover_color, button_rect)\n   self.hover_text   str(i)\n   self.hover_pos   (mouse_pos[0], mouse_pos[1] - 20)\n   else:\n   pygame.draw.rect(buttons_surface, self.number_button_color, button_rect)\n   \n   button_text   self.font.render(str(i), True, (255, 255, 255))\n   buttons_surface.blit(button_text, (x + 15, 8))\n   \n   # Draw buttons surface with clipping\n   buttons_display   pygame.Surface((self.buttons_area_width, self.button_height))\n   buttons_display.fill((255, 255, 255))\n   buttons_display.blit(buttons_surface, (self.scroll_x, 0))\n   self.screen.blit(buttons_display, (30, 60))\n   \n   # Draw control buttons\n   pygame.draw.rect(self.screen, self.submit_button_color, self.submit_button)\n   submit_text   self.font.render(\"Submit\", True, (255, 255, 255))\n   self.screen.blit(submit_text, (20, 130))\n   \n   pygame.draw.rect(self.screen, self.quit_button_color, self.quit_button)\n   quit_text   self.font.render(\"Quit\", True, (255, 255, 255))\n   self.screen.blit(quit_text, (140, 130))\n   \n   pygame.draw.rect(self.screen, self.reset_button_color, self.reset_button)\n   reset_text   self.font.render(\"Reset\", True, (255, 255, 255))\n   self.screen.blit(reset_text, (20, self.HEIGHT - 45))\n   \n   # Draw k input box\n   pygame.draw.rect(self.screen, (200, 200, 200) if self.k_input_active \n   else (100, 100, 100), self.k_input_rect)\n   k_text   self.font.render(self.k_input, True, (255, 255, 255))\n   self.screen.blit(k_text, (130, self.HEIGHT - 45))\n   \n   # Draw current k and best score\n   k_label   self.font.render(f\"Current k: {self.env.k}\", True, (0, 0, 0))\n   self.screen.blit(k_label, (230, self.HEIGHT - 45))\n   \n   if self.env.best_submission:\n   best_score   self.font.render(\n   f\"Best Score: {self.env.best_submission.score}\", True, (0, 0, 0))\n   self.screen.blit(best_score, (400, self.HEIGHT - 45))\n\n   # Draw hover text\n   if self.hover_text:\n   hover_surface   self.font.render(self.hover_text, True, (0, 0, 0))\n   self.screen.blit(hover_surface, self.hover_pos)\n\n   def get_button_at_position(self, pos):\n   adjusted_x   pos[0] - 30 - self.scroll_x\n   if 60 < pos[1] < 60 + self.button_height:\n   button_index   adjusted_x // (self.button_width + self.button_margin)\n   if 0 < button_index < self.env.k:\n   return int(button_index + 1)\n   return None\n\n   def run(self):\n   observation, _   self.env.reset()\n   running   True\n   \n   while running:\n   self.screen.fill((255, 255, 255))\n   \n   # Display current sequence\n   sequence_text   \"Current Sequence: \" + \" \".join(map(str, self.env.sequence))\n   text_surface   self.font.render(sequence_text, True, (0, 0, 0))\n   self.screen.blit(text_surface, (10, 10))\n   \n   # Draw all buttons\n   self.draw_buttons()\n   \n   # Update display\n   pygame.display.flip()\n   \n   # Event handling\n   for event in pygame.event.get():\n   if event.type   pygame.QUIT:\n   running   False\n   \n   elif event.type   pygame.MOUSEBUTTONDOWN:\n   mouse_pos   pygame.mouse.get_pos()\n   button_clicked   self.get_button_at_position(mouse_pos)\n   \n   if button_clicked is not None:\n   observation, reward, done, _, _   self.env.step(button_clicked)\n   \n   elif self.submit_button.collidepoint(mouse_pos):\n   observation, reward, done, _, _   self.env.step(self.env.k)\n   if reward > 0:\n   self.show_submission_result(reward)\n   \n   elif self.quit_button.collidepoint(mouse_pos):\n   self.env.export_best_result()\n   running   False\n   \n   elif self.reset_button.collidepoint(mouse_pos):\n   try:\n   new_k   int(self.k_input) if self.k_input else self.env.k\n   if new_k > 0:\n   observation, _   self.env.reset(knew_k)\n   self.scroll_x   0\n   self.k_input   \"\"\n   except ValueError:\n   pass\n   \n   self.k_input_active   self.k_input_rect.collidepoint(mouse_pos)\n   \n   elif event.type   pygame.KEYDOWN and self.k_input_active:\n   if event.key   pygame.K_RETURN:\n   self.k_input_active   False\n   elif event.key   pygame.K_BACKSPACE:\n   self.k_input   self.k_input[:-1]\n   elif event.unicode.isdigit():\n   self.k_input + event.unicode\n   \n   pygame.quit()\n\n   def show_submission_result(self, reward):\n   \"\"\"Display submission result briefly.\"\"\"\n   overlay   pygame.Surface((300, 100))\n   overlay.fill((255, 255, 255))\n   pygame.draw.rect(overlay, (0, 255, 0), overlay.get_rect(), 2)\n   \n   text   self.font.render(f\"Sequence Score: {reward}\", True, (0, 0, 0))\n   overlay.blit(text, (20, 40))\n   \n   x   (self.WIDTH - overlay.get_width()) // 2\n   y   (self.HEIGHT - overlay.get_height()) // 2\n   \n   self.screen.blit(overlay, (x, y))\n   pygame.display.flip()\n   pygame.time.wait(1000)\n\ndef main():\n   env   SequenceGameEnv(initial_k10, human_playTrue)\n   gui   SequenceGameGUI(env)\n   gui.run()\n\nif __name__   \"__main__\":\n   main()\n\n\\end{lstlisting}\n\n\n\\newpage\n\\clearpage\n\n\\subsubsection*{Problem 3}\n\\label{appendix:G_2023_IMO_Shortlist_C3}\n\n\n\\hrule\n\\begin{lstlisting}[\nlanguagePython, basicstyle\\scriptsize\\ttfamily, numbersleft, breaklinestrue, breakatwhitespacetrue, xleftmargin2em, xrightmargin2em, aboveskip1em, belowskip1em,\ncaption{2023 IMO Shortlist problem 3 game code.},\nlabel{listing:IMO2024SLC3}\n]\nimport pygame\nimport pygame.gfxdraw\nimport gymnasium as gym\nfrom gymnasium import spaces\nimport numpy as np\nimport sys\nimport time\n\n# Gymnasium Environment class definition\nclass IMOEnvironment(gym.Env):\n   metadata   {'render_modes': ['human']}\n   def __init__(self, n6):\n   super(IMOEnvironment, self).__init__()\n   self.n   n   # Number of rows in the triangle\n   self.action_space   spaces.Discrete(2)   # 0: Left, 1: Right\n   self.observation_space   spaces.Tuple((\n   spaces.Discrete(self.n),   # Current row\n   spaces.Discrete(self.n),   # Position in current row\n   spaces.MultiBinary(self.n * (self.n + 1) // 2)   # Red circles configuration\n   ))\n   self.screen_width   800\n   self.screen_height   600\n   self.reset()\n   # Pygame initialization\n   pygame.init()\n   self.screen   pygame.display.set_mode((self.screen_width, self.screen_height))\n   pygame.display.set_caption('IMO Ninja Path Environment')\n   self.clock   pygame.time.Clock()\n   \n   def reset(self):\n   # Initialize the triangle and red circles\n   self.current_row   0\n   self.current_pos   0   # Always start at the top circle\n   self.path   [(self.current_row, self.current_pos)]\n   # Generate red circles: one per row\n   self.red_circles   {}\n   for row in range(self.n):\n   red_pos   np.random.randint(0, row + 1)\n   self.red_circles[row]   red_pos\n   # Create a flattened representation for the observation\n   self.state   (self.current_row, self.current_pos, self._get_red_circles_flat())\n   return self.state\n   \n   def step(self, action):\n   # Action: 0 for Left, 1 for Right\n   done   False\n   reward   0\n\n   # Move to the next row\n   self.current_row + 1\n   if action   0:\n   # Move to the left child\n   self.current_pos   self.current_pos\n   elif action   1:\n   # Move to the right child\n   self.current_pos   self.current_pos + 1\n   else:\n   raise ValueError(\"Invalid action\")\n\n   self.path.append((self.current_row, self.current_pos))\n\n   # Check if landed on a red circle\n   if self.red_circles.get(self.current_row)   self.current_pos:\n   reward   1\n\n   # Check if we have reached the bottom row\n   if self.current_row   self.n - 1:\n   done   True\n\n   self.state   (self.current_row, self.current_pos, self._get_red_circles_flat())\n   info   {}\n   return self.state, reward, done, info\n\n   def render(self, mode'human'):\n   # Handle Pygame events\n   for event in pygame.event.get():\n   if event.type   pygame.QUIT:\n   pygame.quit()\n   sys.exit()\n\n   # Clear the screen\n   self.screen.fill((255, 255, 255))   # White background\n\n   # Parameters for drawing\n   circle_radius   30\n   vertical_spacing   53\n   horizontal_spacing   60\n   start_x   self.screen_width // 2\n   start_y   100\n\n   # Draw the triangle of circles\n   positions   {}\n   for row in range(self.n):\n   row_circles   row + 1\n   row_y   start_y + row * vertical_spacing\n   row_width   (row_circles - 1) * horizontal_spacing\n   for pos in range(row_circles):\n   # Calculate x position\n   x   start_x - row_width // 2 + pos * horizontal_spacing\n   y   row_y\n   positions[(row, pos)]   (x, y)\n\n   # Determine circle color\n   circle_color   (255, 255, 255)   # White\n   if self.red_circles.get(row)   pos:\n   circle_color   (255, 0, 0)   # Red\n\n   # Draw the circle\n   pygame.gfxdraw.filled_circle(self.screen, int(x), int(y), circle_radius, circle_color)\n   pygame.gfxdraw.aacircle(self.screen, int(x), int(y), circle_radius, (0, 0, 0))   # Black border\n\n   # Draw fancy arrows along the path\n   if len(self.path) > 1:\n   for i in range(len(self.path) - 1):\n   start_pos   positions[self.path[i]]\n   end_pos   positions[self.path[i + 1]]\n   self.draw_fancy_arrow(self.screen, (0, 0, 0), start_pos, end_pos)\n\n   # Update the display\n   pygame.display.flip()\n   self.clock.tick(2)   # Limit to 2 frames per second\n\n   def draw_fancy_arrow(self, surface, color, start, end, arrow_width5, arrow_head_length20, arrow_head_width20):\n   # Scale arrow dimensions\n   arrow_width   int(arrow_width)\n   arrow_head_length   int(arrow_head_length)\n   arrow_head_width   int(arrow_head_width)\n\n   # Calculate the direction vector\n   direction   pygame.math.Vector2(end) - pygame.math.Vector2(start)\n   length   direction.length()\n   if length   0:\n   return\n   direction   direction.normalize()\n\n   # Calculate the arrowhead points\n   left_head   end - direction * arrow_head_length + direction.rotate(90) * (arrow_head_width / 2)\n   right_head   end - direction * arrow_head_length + direction.rotate(-90) * (arrow_head_width / 2)\n\n   # Draw the arrow shaft with anti-aliasing\n   pygame.draw.line(surface, color, start, end, arrow_width)\n\n   # Draw the arrowhead\n   pygame.gfxdraw.filled_polygon(surface, [(int(end[0]), int(end[1])),\n   (int(left_head[0]), int(left_head[1])),\n   (int(right_head[0]), int(right_head[1]))], color)\n   pygame.gfxdraw.aapolygon(surface, [(int(end[0]), int(end[1])),\n   (int(left_head[0]), int(left_head[1])),\n   (int(right_head[0]), int(right_head[1]))], color)\n\n   def _get_red_circles_flat(self):\n   # Flatten the red circles into a binary array\n   total_circles   self.n * (self.n + 1) // 2\n   red_circles_flat   np.zeros(total_circles, dtypeint)\n   index   0\n   for row in range(self.n):\n   for pos in range(row + 1):\n   if self.red_circles.get(row)   pos:\n   red_circles_flat[index]   1\n   index + 1\n   return red_circles_flat\n\n   def close(self):\n   if self.render_mode   'human':\n   pygame.quit()\n\n# Main game loop\ndef main():\n   env   IMOEnvironment(n6)\n   state   env.reset()\n   done   False\n   env.render()\n   total_reward   0\n   step_count   0\n   path_taken   []\n\n   while not done:\n   action   env.action_space.sample()\n   time.sleep(0.5)   # Slow down the auto mode for visualization\n   state, reward, done, info   env.step(action)\n   total_reward + reward\n   step_count + 1\n   path_taken.append('Left' if action   0 else 'Right')\n\n   env.render()\n\n   print(f\"Episode finished in {step_count} steps.\")\n   print(f\"Actions taken: {path_taken}\")\n   print(f\"Total reward (number of red circles collected): {total_reward}\")\n   print(\"-\" * 50)\n   time.sleep(1)\n   \n   env.close()\n\nif __name__   \"__main__\":\n   main()\n\n\\end{lstlisting}\n\n\n\\newpage\n\\clearpage\n\n\\subsubsection*{Problem 4}\n\\label{appendix:G_2023_IMO_Shortlist_C4}\n\n\n\n\\hrule\n\\begin{lstlisting}[\nlanguagePython, basicstyle\\scriptsize\\ttfamily, numbersleft, breaklinestrue, breakatwhitespacetrue, xleftmargin2em, xrightmargin2em, aboveskip1em, belowskip1em,\ncaption{2023 IMO Shortlist game code.},\nlabel{listing:IMO2024SLC4}\n]\nimport gymnasium as gym\nfrom gymnasium import spaces\nimport numpy as np\nimport pygame\nimport sys\n\nclass StripToGridEnv(gym.Env):\n   metadata   {'render.modes': ['human']}\n\n   def __init__(self, n3):\n   super(StripToGridEnv, self).__init__()\n   self.n   n\n   self.n2   n * n\n   self.action_space   spaces.MultiBinary(self.n2 - 1)\n   self.observation_space   spaces.MultiBinary(self.n2 - 1)\n   self.state   np.zeros(self.n2 - 1, dtypeint)\n   self.num_cuts   0\n   self.done   False\n   self.screen   None\n   self.clock   None\n   self.isopen   True\n\n   def step(self, action):\n   assert self.action_space.contains(action), f\"{action} ({type(action)}) invalid\"\n   if self.done:\n   return self.state, 0, self.done, {}\n   cuts_made   action.astype(int)\n   new_cuts   np.maximum(self.state, cuts_made)\n   cuts_added   np.sum(new_cuts - self.state)\n   self.state   new_cuts\n   self.num_cuts + cuts_added\n   reward   -cuts_added\n   success   self.attempt_assemble_grid()\n   if success:\n   reward + 1000\n   self.done   True\n   info   {}\n   return self.state, reward, self.done, info\n\n   def reset(self):\n   self.state   np.zeros(self.n2 - 1, dtypeint)\n   self.num_cuts   0\n   self.done   False\n   return self.state\n\n   def render(self, mode'human'):\n   if self.screen is None:\n   pygame.init()\n   pygame.display.init()\n   self.size   self.width, self.height   300, 300\n   self.screen   pygame.display.set_mode(self.size)\n   pygame.display.set_caption(\"Strip to Grid Animation\")\n   self.clock   pygame.time.Clock()\n   self.WHITE   (255, 255, 255)\n   self.BLACK   (0, 0, 0)\n   self.GROUP_COLORS   [\n   (255, 200, 200),\n   (200, 255, 200),\n   (200, 200, 255),\n   (255, 255, 200),\n   (200, 255, 255),\n   (255, 200, 255),\n   (240, 240, 240),\n   (200, 200, 200),\n   (150, 150, 150),\n   ]\n   self.cell_size   self.width // self.n\n   self.font   pygame.font.SysFont(None, 40)\n   self.arrived_pieces   []\n   self.moving_pieces   []\n   self.pieces_initialized   False\n   self.screen.fill(self.WHITE)\n   for event in pygame.event.get():\n   if event.type   pygame.QUIT:\n   self.isopen   False\n   for i in range(self.n + 1):\n   pygame.draw.line(self.screen, self.BLACK, (0, i * self.cell_size), (self.width, i * self.cell_size), 2)\n   pygame.draw.line(self.screen, self.BLACK, (i * self.cell_size, 0), (i * self.cell_size, self.height), 2)\n   if not self.pieces_initialized:\n   self.prepare_pieces()\n   self.pieces_initialized   True\n   if not self.done:\n   self.animate_pieces()\n   else:\n   self.draw_all_pieces()\n   pygame.display.flip()\n   self.clock.tick(60)\n\n   def close(self):\n   if self.screen is not None:\n   pygame.display.quit()\n   pygame.quit()\n   self.isopen   False\n\n   def attempt_assemble_grid(self):\n   cut_positions   np.where(self.state   1)[0] + 1\n   piece_indices   np.split(np.arange(1, self.n2 + 1), cut_positions)\n   labels   np.concatenate(piece_indices)\n   if len(labels) ! self.n2:\n   return False\n   grid   np.reshape(labels, (self.n, self.n))\n   for i in range(self.n):\n   for j in range(self.n):\n   a_ij   grid[i, j]\n   if (a_ij - (i + 1 + j + 1 - 1))   self.n ! 0:\n   return False\n   return True\n\n   def prepare_pieces(self):\n   cut_positions   np.where(self.state   1)[0] + 1\n   piece_indices   np.split(np.arange(1, self.n2 + 1), cut_positions)\n   self.pieces   {}\n   self.piece_order   []\n   self.start_positions   {}\n   self.moving_pieces   {}\n   self.arrived_pieces   []\n   group   0\n   offsets   [(-self.cell_size * self.n, 0), (self.width, 0), (0, -self.cell_size * self.n)]\n   offset_index   0\n   row   0\n   col   0\n   for idx, piece in enumerate(piece_indices):\n   piece_size   len(piece)\n   cells   []\n   numbers   []\n   for p in piece:\n   cells.append((row, col))\n   numbers.append(p)\n   col + 1\n   if col > self.n:\n   col   0\n   row + 1\n   start_pos   offsets[offset_index   len(offsets)]\n   offset_index + 1\n   self.pieces[group]   {\n   'cells': cells,\n   'numbers': numbers,\n   'start_pos': start_pos,\n   }\n   self.piece_order.append(group)\n   group + 1\n   for group in self.piece_order:\n   piece   self.pieces[group]\n   self.moving_pieces[group]   {\n   'positions': [],\n   'cells': piece['cells'],\n   'numbers': piece['numbers'],\n   'start_pos': list(piece['start_pos']),\n   'current_pos': list(piece['start_pos']),\n   'target_cells': piece['cells'],\n   'arrived': False,\n   }\n   self.current_piece_index   0\n   self.move_speed   5\n\n   def animate_pieces(self):\n   for group in self.arrived_pieces:\n   self.draw_piece(group, final_positionTrue)\n   if self.current_piece_index < len(self.piece_order):\n   group   self.piece_order[self.current_piece_index]\n   piece_info   self.moving_pieces[group]\n   if not piece_info['arrived']:\n   target_x   piece_info['target_cells'][0][1] * self.cell_size\n   target_y   piece_info['target_cells'][0][0] * self.cell_size\n   dx   target_x - piece_info['current_pos'][0]\n   dy   target_y - piece_info['current_pos'][1]\n   dist   (dx ** 2 + dy ** 2) ** 0.5\n   if dist < self.move_speed:\n   piece_info['current_pos'][0]   target_x\n   piece_info['current_pos'][1]   target_y\n   piece_info['arrived']   True\n   self.arrived_pieces.append(group)\n   self.current_piece_index + 1\n   else:\n   piece_info['current_pos'][0] + self.move_speed * dx / dist\n   piece_info['current_pos'][1] + self.move_speed * dy / dist\n   self.draw_piece(group)\n   else:\n   self.done   True\n\n   def draw_piece(self, group, final_positionFalse):\n   piece_info   self.moving_pieces[group]\n   for idx, (cell_row, cell_col) in enumerate(piece_info['cells']):\n   number   piece_info['numbers'][idx]\n   group_color   self.GROUP_COLORS[group   len(self.GROUP_COLORS)]\n   if final_position:\n   cell_x   cell_col * self.cell_size\n   cell_y   cell_row * self.cell_size\n   else:\n   cell_offset_x   (cell_col - piece_info['target_cells'][0][1]) * self.cell_size\n   cell_offset_y   (cell_row - piece_info['target_cells'][0][0]) * self.cell_size\n   cell_x   piece_info['current_pos'][0] + cell_offset_x\n   cell_y   piece_info['current_pos'][1] + cell_offset_y\n   cell_rect   pygame.Rect(cell_x, cell_y, self.cell_size, self.cell_size)\n   pygame.draw.rect(self.screen, group_color, cell_rect)\n   pygame.draw.rect(self.screen, self.BLACK, cell_rect, 2)\n   text   self.font.render(str(number), True, self.BLACK)\n   text_rect   text.get_rect(centercell_rect.center)\n   self.screen.blit(text, text_rect)\n\n   def draw_all_pieces(self):\n   for group in self.piece_order:\n   self.draw_piece(group, final_positionTrue)\n\ndef main():\n   env   StripToGridEnv(n3)\n   state   env.reset()\n   done   False\n   action   np.zeros(env.n2 - 1)\n   action[2]   1   # Cut after position 3\n   action[5]   1   # Cut after position 6\n\n   state, reward, done, info   env.step(action)\n   env.render()\n\n   while env.isopen:\n   env.render()\n\n   env.close()\n\nif __name__   \"__main__\":\n   main()\n\\end{lstlisting}\n\n\n\n\n\\newpage\n\\clearpage\n\n\\subsubsection*{Problem 5}\n\\label{appendix:G_2023_IMO_Shortlist_C5}\n\n\n\\hrule\n\\begin{lstlisting}[\nlanguagePython, basicstyle\\scriptsize\\ttfamily, numbersleft, breaklinestrue, breakatwhitespacetrue, xleftmargin2em, xrightmargin2em, aboveskip1em, belowskip1em,\ncaption{2023 IMO Shortlist game code.},\nlabel{listing:IMO2024SLC5}\n]\nimport gymnasium as gym\nfrom gymnasium import spaces\nimport pygame\nimport numpy as np\nimport time\n\nclass TreasureChestEnv(gym.Env):\n   metadata   {\"render_modes\": [\"human\", \"rgb_array\"], \"render_fps\": 4}\n\n   def __init__(self, num_chests5, render_modeNone):\n   super(TreasureChestEnv, self).__init__()\n   \n   self.render_mode   render_mode\n   self.num_chests   num_chests\n   self.window_size   (800, 600)\n   self.chest_width   min(100, 700 // self.num_chests)\n   self.chest_height   80\n   self.step_count   0\n   self.all_time_max_diff   0   # Track all-time maximum difference\n   \n   # Action space: which chest to put gem in\n   self.action_space   spaces.Discrete(num_chests)\n   \n   # Observation space\n   self.observation_space   spaces.Dict({\n   'gems': spaces.Box(low0, highfloat('inf'), shape(num_chests,), dtypenp.float32),\n   'locks': spaces.Box(low0, high1, shape(num_chests,), dtypenp.int8)\n   })\n\n   # Initialize pygame\n   self.window   None\n   self.clock   None\n   self.previous_max_diff   0\n   \n   # Button states\n   self.step_requested   False\n   self.step_count_requested   0\n   \n   def reset(self, seedNone):\n   super().reset(seedseed)\n   self.gems   np.zeros(self.num_chests, dtypenp.float32)\n   self.locks   np.zeros(self.num_chests, dtypenp.int8)\n   self.previous_max_diff   0\n   self.warning_message   \"\"\n   self.warning_timer   0\n   self.step_count   0\n   # Removed all_time_max_diff reset to maintain it across regular resets\n   \n   observation   {\n   'gems': self.gems.copy(),\n   'locks': self.locks.copy()\n   }\n   \n   if self.render_mode   \"human\":\n   self._render_frame()\n   \n   return observation, {}\n\n   def reset_with_new_chests(self, new_num_chests):\n   \"\"\"Reset the environment with a new number of chests\"\"\"\n   self.num_chests   new_num_chests\n   self.chest_width   min(100, 700 // self.num_chests)\n   self.action_space   spaces.Discrete(new_num_chests)\n   self.observation_space   spaces.Dict({\n   'gems': spaces.Box(low0, highfloat('inf'), shape(new_num_chests,), dtypenp.float32),\n   'locks': spaces.Box(low0, high1, shape(new_num_chests,), dtypenp.int8)\n   })\n   self.all_time_max_diff   0   # Only reset all-time max when changing chest count\n   return self.reset()\n   \n   def choose_best_action(self):\n   \"\"\"AI strategy: Choose the unlocked chest with minimum gems\"\"\"\n   unlocked_chests   np.where(self.locks   0)[0]\n   if len(unlocked_chests)   0:\n   return None\n   \n   gems_unlocked   self.gems[unlocked_chests]\n   min_gem_idx   unlocked_chests[np.argmin(gems_unlocked)]\n   return min_gem_idx\n\n   def step(self, actionNone):\n   if action is None:\n   action   self.choose_best_action()\n   if action is None:\n   self.warning_message   \"No valid moves available!\"\n   self.warning_timer   time.time()\n   return self._get_obs(), -1, True, False, {'invalid_action': True}\n   \n   self.step_count + 1\n   \n   if not self._is_valid_action(action):\n   self.warning_message   f\"Chest #{action} is locked! Choosing another chest.\"\n   self.warning_timer   time.time()\n   return self._get_obs(), -1, False, False, {'invalid_action': True}\n   \n   self.gems[action] + 1\n   self._fairy_action()\n   \n   current_max_diff   np.max(self.gems) - np.min(self.gems)\n   self.all_time_max_diff   max(self.all_time_max_diff, current_max_diff)\n   \n   if current_max_diff < self.previous_max_diff:\n   reward   10\n   elif current_max_diff > self.previous_max_diff:\n   reward   -10\n   else:\n   reward   1\n   \n   self.previous_max_diff   current_max_diff\n   \n   if self.render_mode   \"human\":\n   self._render_frame()\n   \n   return self._get_obs(), reward, False, False, {\n   'max_diff': current_max_diff,\n   'unlocked_count': np.sum(self.locks   0),\n   'all_time_max_diff': self.all_time_max_diff\n   }\n   \n   def _is_valid_action(self, action):\n   return self.locks[action]   0\n   \n   def _fairy_action(self):\n   \"\"\"Modified fairy strategy: Lock chest with minimum gems to maximize difference\"\"\"\n   unlocked_chests   np.where(self.locks   0)[0]\n   if len(unlocked_chests) > 1:\n   # Get gems count of unlocked chests\n   unlocked_gems   self.gems[unlocked_chests]\n   # Find indices of chests with minimum gems\n   min_gem_value   np.min(unlocked_gems)\n   min_gem_indices   unlocked_chests[unlocked_gems   min_gem_value]\n   # Randomly choose one of the chests with minimum gems\n   chest_to_lock   self.np_random.choice(min_gem_indices)\n   self.locks[chest_to_lock]   1\n   elif len(unlocked_chests)   1:\n   self.locks[:]   0\n   \n   def _get_obs(self):\n   return {\n   'gems': self.gems.copy(),\n   'locks': self.locks.copy()\n   }\n   \n   def _render_frame(self):\n   if self.window is None and self.render_mode   \"human\":\n   pygame.init()\n   pygame.display.init()\n   self.window   pygame.display.set_mode(self.window_size)\n   pygame.display.set_caption(\"Treasure Distribution Analysis\")\n   self.clock   pygame.time.Clock()\n   self.font   pygame.font.Font(None, 36)\n   \n   if self.window is not None:\n   # Fill background\n   self.window.fill((255, 255, 255))\n   \n   # Draw title\n   title   self.font.render(\"Treasure Distribution Analysis\", True, (0, 0, 0))\n   step_text   self.font.render(f\"Step Count: {self.step_count}\", True, (128, 128, 128))\n   \n   title_rect   title.get_rect(center(self.window_size[0]//2, 30))\n   step_rect   step_text.get_rect(center(self.window_size[0]//2, 60))\n   \n   self.window.blit(title, title_rect)\n   self.window.blit(step_text, step_rect)\n   \n   # Draw buttons (centered, above the grid)\n   buttons_y   100\n   button_width   80\n   button_height   30\n   button_spacing   10\n   total_buttons_width   (button_width * 5) + (button_spacing * 4)\n   start_x   (self.window_size[0] - total_buttons_width) // 2\n   \n   buttons   [\n   (\"Step +1\", (start_x, buttons_y)),\n   (\"Step +10\", (start_x + button_width + button_spacing, buttons_y)),\n   (\"Reset\", (start_x + (button_width + button_spacing) * 2, buttons_y)),\n   (\"N-1\", (start_x + (button_width + button_spacing) * 3, buttons_y)),\n   (\"N+1\", (start_x + (button_width + button_spacing) * 4, buttons_y))\n   ]\n   \n   button_rects   []\n   for text, pos in buttons:\n   button_rect   pygame.Rect(pos[0], pos[1], button_width, button_height)\n   pygame.draw.rect(self.window, (255, 255, 255), button_rect)\n   pygame.draw.rect(self.window, (0, 0, 0), button_rect, 1)\n   \n   button_text   self.font.render(text, True, (0, 0, 0))\n   text_rect   button_text.get_rect(centerbutton_rect.center)\n   self.window.blit(button_text, text_rect)\n   button_rects.append(button_rect)\n   \n   # Draw chests grid\n   grid_top   150\n   chest_size   96   # 24px * 4 to match the React version\n   grid_spacing   4\n   total_grid_width   (chest_size * self.num_chests) + (grid_spacing * (self.num_chests - 1))\n   start_x   (self.window_size[0] - total_grid_width) // 2\n   \n   for i in range(self.num_chests):\n   x   start_x + i * (chest_size + grid_spacing)\n   \n   # Draw chest box\n   chest_rect   pygame.Rect(x, grid_top, chest_size, chest_size)\n   chest_color   (230, 230, 230) if self.locks[i] else (255, 255, 255)\n   pygame.draw.rect(self.window, chest_color, chest_rect)\n   pygame.draw.rect(self.window, (0, 0, 0), chest_rect, 1)\n   \n   # Draw chest number\n   num_text   self.font.render(f\"#{i}\", True, (0, 0, 0))\n   num_rect   num_text.get_rect(topleft(x + 4, grid_top + 4))\n   self.window.blit(num_text, num_rect)\n   \n   # Draw lock status\n   lock_text   self.font.render(\"\\textbullet{}\" if self.locks[i] else \"\\textsquare{}\", True, (0, 0, 0))\n   lock_rect   lock_text.get_rect(topright(x + chest_size - 4, grid_top + 4))\n   self.window.blit(lock_text, lock_rect)\n   \n   # Draw gems count\n   if self.gems[i] > 0:\n   gem_text   self.font.render(f\"x{int(self.gems[i])}\", True, (0, 0, 0))\n   gem_rect   gem_text.get_rect(bottomleft(x + 4, grid_top + chest_size - 4))\n   self.window.blit(gem_text, gem_rect)\n   \n   # Draw legend\n   legend_y   grid_top + chest_size + 40\n   legend_text   self.font.render(\"\\textsquare{} : unlocked   \\textbullet{} : locked\", True, (0, 0, 0))\n   legend_rect   legend_text.get_rect(center(self.window_size[0]//2, legend_y))\n   legend_box   pygame.Rect(\n   legend_rect.left - 10, \n   legend_rect.top - 5,\n   legend_rect.width + 20,\n   legend_rect.height + 10\n   )\n   pygame.draw.rect(self.window, (255, 255, 255), legend_box)\n   pygame.draw.rect(self.window, (0, 0, 0), legend_box, 1)\n   self.window.blit(legend_text, legend_rect)\n   \n   pygame.display.flip()\n   self.clock.tick(self.metadata[\"render_fps\"])\n   \n   return button_rects\n   \n   def _draw_buttons(self):\n   # This method is now handled within _render_frame\n   button_width   80\n   button_height   30\n   button_spacing   10\n   buttons_y   100\n   total_buttons_width   (button_width * 5) + (button_spacing * 4)\n   start_x   (self.window_size[0] - total_buttons_width) // 2\n   \n   step_button   pygame.Rect(start_x, buttons_y, button_width, button_height)\n   step10_button   pygame.Rect(start_x + button_width + button_spacing, buttons_y, button_width, button_height)\n   reset_button   pygame.Rect(start_x + (button_width + button_spacing) * 2, buttons_y, button_width, button_height)\n   decrease_button   pygame.Rect(start_x + (button_width + button_spacing) * 3, buttons_y, button_width, button_height)\n   increase_button   pygame.Rect(start_x + (button_width + button_spacing) * 4, buttons_y, button_width, button_height)\n   \n   return step_button, step10_button, reset_button, decrease_button, increase_button\n   def close(self):\n   if self.window is not None:\n   pygame.display.quit()\n   pygame.quit()\ndef main():\n   env   TreasureChestEnv(num_chests5, render_mode\"human\")\n   obs, _   env.reset()\n   \n   running   True\n   while running:\n   step_button, step10_button, reset_button, decrease_button, increase_button   env._draw_buttons()\n   \n   for event in pygame.event.get():\n   if event.type   pygame.QUIT:\n   running   False\n   elif event.type   pygame.MOUSEBUTTONDOWN:\n   mouse_pos   event.pos\n   if step_button.collidepoint(mouse_pos):\n   obs, reward, terminated, truncated, info   env.step()\n   print(f\"Step +1: Reward{reward}, Max Diff{info['max_diff']}\")\n   print(f\"Gems: {tuple(env.gems.astype(int))}, Locks: {tuple(env.locks)}\")\n   elif step10_button.collidepoint(mouse_pos):\n   for _ in range(10):\n   obs, reward, terminated, truncated, info   env.step()\n   print(f\"Step +10: Final Reward{reward}, Max Diff{info['max_diff']}\")\n   print(f\"Gems: {tuple(env.gems.astype(int))}, Locks: {tuple(env.locks)}\")\n   elif reset_button.collidepoint(mouse_pos):\n   obs, _   env.reset()\n   print(\"Environment reset\")\n   print(f\"Gems: {tuple(env.gems.astype(int))}, Locks: {tuple(env.locks)}\")\n   elif decrease_button.collidepoint(mouse_pos) and env.num_chests > 2:\n   obs, _   env.reset_with_new_chests(env.num_chests - 1)\n   print(f\"Decreased to {env.num_chests} chests\")\n   print(f\"Gems: {tuple(env.gems.astype(int))}, Locks: {tuple(env.locks)}\")\n   elif increase_button.collidepoint(mouse_pos) and env.num_chests < 15:\n   obs, _   env.reset_with_new_chests(env.num_chests + 1)\n   print(f\"Increased to {env.num_chests} chests\")\n   print(f\"Gems: {tuple(env.gems.astype(int))}, Locks: {tuple(env.locks)}\")\n   env._render_frame()\n   \n   env.close()\n\nif __name__   \"__main__\":\n   main()\n\\end{lstlisting}\n\n\\newpage\n\\clearpage\n\n\n\\subsubsection*{Problem 7}\n\\label{appendix:G_2023_IMO_Shortlist_C7}\n\n\n\\hrule\n\\begin{lstlisting}[\nlanguagePython, basicstyle\\scriptsize\\ttfamily, numbersleft, breaklinestrue, breakatwhitespacetrue, xleftmargin2em, xrightmargin2em, aboveskip1em, belowskip1em,\ncaption{IMO 2023 Shortlist problem 7 game code.},\nlabel{listing:IMO2024SLC7}\n]\nimport gym\nfrom gym import spaces\nimport numpy as np\nimport networkx as nx\nimport math\nfrom itertools import permutations\nimport pygame\nimport sys\nimport time\n\n# Constants for visualization (optional)\nWINDOW_WIDTH   800\nWINDOW_HEIGHT   600\nNODE_RADIUS   20\nEDGE_WIDTH   2\nFPS   60\n\n# Colors (optional)\nWHITE   (255, 255, 255)\nBLACK   (0, 0, 0)\nGRAY   (180, 180, 180)\nLIGHT_GRAY   (220, 220, 220)\nTEXT_COLOR   (0, 0, 0)\nHIGHLIGHT_COLOR   (255, 0, 0)\n\n# Define a set of colors for companies (companies' colors)\nCOMPANY_COLORS   [\n   (0, 255, 255),   # Cyan\n   (0, 255, 0),   # Green\n   (255, 165, 0),   # Orange\n   (0, 0, 255),   # Blue\n   (128, 0, 128),   # Purple\n   (255, 192, 203),   # Pink\n   (128, 128, 0),   # Olive\n   (0, 128, 128),   # Teal\n   (255, 215, 0),   # Gold\n   (0, 0, 0),   # Black\n   (255, 255, 255)   # White\n]\n\n\nclass ImoniFerryLineEnv(gym.Env):\n   metadata   {'render.modes': ['human']}\n\n   def __init__(self, n, k, renderFalse):\n   self.render_mode   render\n   # Initialize Pygame only if rendering is enabled\n   if self.render_mode:\n   pygame.init()\n   self.window   pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))\n   pygame.display.set_caption(\"IMO Gym Environment Visualization\")\n   self.clock   pygame.time.Clock()\n   self.font   pygame.font.SysFont(None, 24)\n\n   super(ImoniFerryLineEnv, self).__init__()\n   self.n   n   # Number of islands (nodes)\n   self.k   k   # Number of companies\n\n   # Initialize the graph\n   self.graph   nx.complete_graph(n)\n   self.original_graph   self.graph.copy()\n\n   # Assign initial colors\n   self.assign_node_colors()\n   self.assign_edge_colors()\n\n   # Define action and observation space\n   # Actions: Remove a company's edges or decide to terminate\n   # Action k corresponds to deciding to terminate and make a prediction\n   self.action_space   spaces.Discrete(k + 1)\n\n   # Observation space: Adjacency matrix with company labels\n   # Each edge can have k possible colors or -1 if removed\n   self.observation_space   spaces.Box(low-1, highk - 1, shape(n * n,), dtypenp.int32)\n\n   # Initialize Pygame for visualization (optional)\n   pygame.init()\n   self.window   pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))\n   pygame.display.set_caption(\"IMO Gym Environment Visualization\")\n   self.clock   pygame.time.Clock()\n   self.font   pygame.font.SysFont(None, 24)\n\n   # Node positions\n   self.positions   self._generate_node_positions()\n\n   # Control variables\n   self.removed_colors   []\n   self.current_step   0\n   self.max_steps   k + 1   # Removing k companies and then deciding\n   self.done   False\n\n   def _generate_node_positions(self):\n   # Position nodes in a circle\n   center_x   WINDOW_WIDTH // 2\n   center_y   WINDOW_HEIGHT // 2\n   radius   min(WINDOW_WIDTH, WINDOW_HEIGHT) // 2 - 50\n   positions   []\n   for i in range(self.n):\n   angle   2 * np.pi * i / self.n\n   x   center_x + int(radius * np.cos(angle))\n   y   center_y + int(radius * np.sin(angle))\n   positions.append((x, y))\n   return positions\n\n   def assign_node_colors(self):\n   # Assign colors to nodes based on the formula (if needed)\n   # Currently not used in observation; can be expanded\n   self.node_colors   np.zeros(self.n, dtypeint)   # Placeholder\n\n   def assign_edge_colors(self):\n   # Assign colors to edges based on the colors of their incident nodes\n   # For simplicity, assign colors sequentially\n   self.edge_colors   {}\n   for idx, (i, j) in enumerate(self.graph.edges()):\n   color   idx   self.k   # Simple assignment\n   self.edge_colors[(i, j)]   color\n\n   def step(self, action):\n   \"\"\"\n   Execute one time step within the environment.\n   \"\"\"\n   if self.done:\n   return self._get_obs(), 0, self.done, {}\n\n   reward   0\n   info   {}\n\n   if action < self.k:\n   # Remove all edges of the selected company\n   removed_company   action\n   self.removed_colors.append(removed_company)\n   edges_to_remove   [edge for edge, color in self.edge_colors.items() if color   removed_company]\n   self.graph.remove_edges_from(edges_to_remove)\n   self.current_step + 1\n   print(f\"Removed company {removed_company}, edges: {edges_to_remove}\")\n\n   # Check for Hamiltonian path after each removal\n   has_path   self.has_hamiltonian_path()\n   print(f\"Hamiltonian Path Exists: {has_path}\")\n   # No immediate reward; reward is given upon termination\n   elif action   self.k:\n   # Decide to terminate and make a prediction about maximal k\n   # Here, we'll simulate the agent's prediction\n   # For simplicity, assume the agent predicts the current number of removed companies as k\n   predicted_k   len(self.removed_colors)\n   actual_k   self.k\n   if predicted_k   actual_k:\n   reward   1   # Correct prediction\n   else:\n   reward   -1   # Incorrect prediction\n   self.done   True\n   print(f\"Agent predicted k{predicted_k}, actual k{actual_k}, Reward: {reward}\")\n   else:\n   raise ValueError(\"Invalid Action\")\n\n   obs   self._get_obs()\n\n   return obs, reward, self.done, info\n\n   def reset(self):\n   \"\"\"\n   Reset the state of the environment to an initial state.\n   \"\"\"\n   self.graph   self.original_graph.copy()\n   self.removed_colors   []\n   self.current_step   0\n   self.done   False\n   return self._get_obs()\n\n   def render(self, mode'human'):\n   \"\"\"\n   Render the environment to the screen.\n   \"\"\"\n   self.window.fill(WHITE)\n   # Draw edges\n   for i, j in self.graph.edges():\n   color_index   self.edge_colors.get((i, j), -1)\n   if color_index   -1:\n   color   LIGHT_GRAY   # Removed edge\n   else:\n   color   COMPANY_COLORS[color_index   len(COMPANY_COLORS)]\n   start_pos   self.positions[i]\n   end_pos   self.positions[j]\n   pygame.draw.line(self.window, color, start_pos, end_pos, EDGE_WIDTH)\n\n   # Draw nodes\n   for idx, (x, y) in enumerate(self.positions):\n   node_color   COMPANY_COLORS[self.node_colors[idx]   len(COMPANY_COLORS)]\n   pygame.draw.circle(self.window, node_color, (x, y), NODE_RADIUS)\n   label   self.font.render(str(idx + 1), True, BLACK)\n   label_rect   label.get_rect(center(x, y))\n   self.window.blit(label, label_rect)\n\n   # Draw step information\n   step_text   f\"Step: {self.current_step}/{self.max_steps}\"\n   step_surface   self.font.render(step_text, True, TEXT_COLOR)\n   self.window.blit(step_surface, (10, 10))\n\n   # Display removed companies\n   removed_text   f\"Removed Companies: {self.removed_colors}\"\n   removed_surface   self.font.render(removed_text, True, TEXT_COLOR)\n   self.window.blit(removed_surface, (10, 30))\n\n   # Display instructions\n   instructions   \"Press ESC to exit.\"\n   instructions_surface   self.font.render(instructions, True, TEXT_COLOR)\n   self.window.blit(instructions_surface, (10, WINDOW_HEIGHT - 30))\n\n   pygame.display.flip()\n   self.clock.tick(FPS)\n   self.handle_events()\n\n   def close(self):\n   \"\"\"\n   Clean up the environment.\n   \"\"\"\n   pygame.quit()\n\n   def _get_obs(self):\n   \"\"\"\n   Return the current observation.\n   \"\"\"\n   # Create an adjacency matrix with company labels\n   adj_matrix   np.full((self.n, self.n), -1, dtypeint)\n   for i, j in self.graph.edges():\n   adj_matrix[i, j]   self.edge_colors.get((i, j), -1)\n   adj_matrix[j, i]   self.edge_colors.get((j, i), -1)   # Ensure symmetry\n   return adj_matrix.flatten()\n\n   def has_hamiltonian_path(self):\n   \"\"\"\n   Check if the current graph has a Hamiltonian path.\n   \"\"\"\n   # For small n, this is feasible\n   nodes   list(self.graph.nodes())\n   for perm in permutations(nodes):\n   if all(self.graph.has_edge(perm[i], perm[i + 1]) for i in range(len(perm) - 1)):\n   return True\n   return False\n\n   def handle_events(self):\n   \"\"\"\n   Handle Pygame events.\n   \"\"\"\n   for event in pygame.event.get():\n   if event.type   pygame.QUIT:\n   self.close()\n   sys.exit()\n   elif event.type   pygame.KEYDOWN:\n   if event.key   pygame.K_ESCAPE:\n   self.close()\n   sys.exit()\n\n\\end{lstlisting}\n",
  "title": "main"
}
