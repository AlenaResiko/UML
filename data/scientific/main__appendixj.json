{
  "authors": [
    "Iddo Drori",
    "Gaston Longhitano",
    "Mao Mao",
    "Seunghwan Hyun",
    "Yuke Zhang",
    "Sungjun Park",
    "Zachary Meeks",
    "Xin-Yu Zhang",
    "Ben Segev",
    "Howard Yong",
    "Nakul Verma",
    "Avi Shporer",
    "Alon Amit",
    "Madeleine Udell"
  ],
  "date_published": "2025-02-14",
  "raw_tex": "\\section{Autoformalization of Combinatorics Theorems in Lean}\n\\label{appendix:J}\n\n\n\\subsection*{2024 IMO}\n\\begin{tcolorbox}[enhanced, breakable, rounded corners,\n   colbackgreen!5!white, colframegreen!75!black,\n   colbacktitlegreen!85!black, fonttitle\\bfseries, coltitlewhite, titleAutoformalization for 2024 IMO Problem 5]\n\\setlength{\\parskip}{1em}\n\\begin{lstlisting}[\nlanguagePython, basicstyle\\scriptsize\\ttfamily, numbersleft, breaklinestrue, breakatwhitespacetrue, xleftmargin2em, xrightmargin2em, aboveskip1em, belowskip1em, mathescapetrue\n]\n\nimport Mathlib.Data.Finset.Basic\nimport Mathlib.Tactic\n\nnamespace IMO2024P5\n\n/--\nCoordinates on the board are given by a row index (0 < row < 2024)\nand a column index (0 < col < 2023).\n-/\nstructure Coords where\n   row : Fin 2024\n   col : Fin 2023\n\n/--\nA monster placement on the 2024x2023 board. There is exactly one monster\nin each row except the first (row   0) and the last (row   2023), and\neach column contains at most one monster.\n-/\nstructure MonsterPlacement where\n   /-- $monster c$ means there is a monster at the coordinates $c$. -/\n   monster : Coords $\\to$ Prop\n\n   /--\n   Exactly one monster in each \"middle\" row:\n   for each row $r$ with $r \\neq 0$ and $r \\neq 2023$,\n   there is exactly one column $c$ such that $monster (\\langle r,c\\rangle )$ holds.\n   -/\n   exactly_one_monster_per_row :\n   $\\forall$ r : Fin 2024,\n   $r.val \\neq 0 \\land   r.val \\neq 2023 \\to\n   \\exists!$   (c : Fin 2023), $monster \\langle r, c\\rangle $\n\n   /--\n   Each column contains at most one monster:\n   if $monster (\\langle r_{1}, c\\rangle )$ and $monster (\\langle r_{2}, c\\rangle )$, then $r_{1}   r_{2}$.\n   -/\n   at_most_one_monster_per_col :\n   \\forall (c : Fin 2023) (r_{1} r_{2} : Fin 2024),\n   $monster \\langle r_{1}, c\\rangle   \\to monster \\langle r_{2}, c\\rangle   \\to r_{1}   r_{2}$\n\n/--\nTwo board cells are adjacent if and only if they share a common side,\ni.e., they lie in the same row with consecutive columns, or the same\ncolumn with consecutive rows.\n-/\ndef adjacent (x y : Coords) : Prop :\n   (x.row   y.row $\\land$   (x.col.val + 1   y.col.val $\\lor$ x.col.val   y.col.val + 1)) $\\lor$\n   (x.col   y.col $\\land$   (x.row.val + 1   y.row.val $\\lor$ x.row.val   y.row.val + 1))\n\n/--\nAn attempt is a finite path starting in row 0 and moving step-by-step\nto adjacent cells. The attempt ends as soon as Turbo either encounters\na monster or reaches row 2023.\n-/\nstructure Attempt where\n   /-- The finite sequence of coordinates in the path. -/\n   path : List Coords\n   /-- The first cell is in the top row (row   0). -/\n   start_in_top : path.head?.map ($\\cdot$.row.val)   some 0\n   /-- Consecutive cells in the path are adjacent. -/\n   steps_adjacent : $\\forall$ (i : $\\mathbb{N}$), i < path.length - 1 $\\to$ adjacent (path.nthLe i (by linarith)) (path.nthLe (i+1) (by linarith))\n   /-- The last cell is either in row 2023 (success) or contains a monster (failure). -/\n   end_condition : (path.last?.map ($\\cdot$.row.val)   some 2023)$ \\lor$\n   $\\exists$ c, path.last?   some c $\\land$   False -- We'll refine to a monster condition below.\n\n/--\nWe say that an attempt \"hits a monster\" in a given $placement$ if its last cell\ncontains a monster (i.e., Turbo is forced back to the top). Conversely, if\nthe last cell is in row 2023, Turbo successfully reaches the bottom row.\n-/\ndef attempt_hits_monster (placement : MonsterPlacement) (A : Attempt) : Prop :\n   match A.path.last? with\n   | none   > False   -- Empty path (not really allowed by the problem, but for completeness)\n   | some c > placement.monster c $\\land$   c.row.val $\\neq$ 2023\n\ndef attempt_reaches_last_row (A : Attempt) : Prop :\n   match A.path.last? with\n   | none   > False\n   | some c > c.row.val   2023\n\n/--\nA (high-level) strategy for Turbo up to $n$ attempts means: no matter how\nthe monsters are placed, Turbo can adapt each new attempt based on all\ninformation learned so far (which cells are known to have monsters),\nand is guaranteed to reach the last row by or before the $n$-th attempt.\n-/\ndef TurboHasStrategy (n : $\\mathbb{N}$) : Prop :\n   $\\forall$ (placement : MonsterPlacement),\n   -- \"$\\exists$ strategy\" that guarantees success in $\\leq$ n attempts,\n   -- regardless of where the monsters are located.\n   $\\exists$ (attempts : Fin n.succ $\\to$ Attempt),\n   -- The idea is that each attempt can depend on the knowledge\n   -- gained from previous attempts (which cells had monsters).\n   -- We do not formalize that dependency here, but we require\n   -- that by the final attempt, Turbo has reached row 2023.\n   $\\exists$ (k : Fin n.succ), attempt_reaches_last_row (attempts k)\n\n/--\nWe denote by solution_value the minimum number of attempts $n$ such that\nTurbo can guarantee reaching the last row in at most $n$ attempts, no matter\nhow the monsters are placed.\n-/\nabbrev solution_value : $\\mathbb{N}$ : sorry\n\n/--\nFinal statement of the problem: Determine (prove) the minimum $n$ such that\nTurbo has a winning strategy on or before the $n$-th attempt, for any\nvalid monster placement.\n-/\ntheorem snail_game :\n   IsGreatest {n | TurboHasStrategy n} (solution_value) :\nsorry\n\nend IMO2024P5\n\\end{lstlisting}\n\\end{tcolorbox}\n\n\\begin{tcolorbox}[enhanced, breakable, rounded corners,\n   colbackgreen!5!white, colframegreen!75!black,\n   colbacktitlegreen!85!black, fonttitle\\bfseries, coltitlewhite, title2024 IMO Problem 5 Back-translation]\n\\setlength{\\parskip}{1em}\n\\textbf{Problem Statement.} Consider a \\(2024\\times 2023\\) rectangular grid whose rows are numbered from \\(0\\) to \\(2023\\) and whose columns are numbered from \\(0\\) to \\(2022\\). In each of the rows \\(1, 2, \\ldots, 2022\\), exactly one cell contains a monster, and no column contains more than one monster. (In other words, for each row \\(r\\in\\{1,\\dots,2022\\}\\) there is exactly one column \\(c\\) so that the cell \\((r,c)\\) contains a monster, and different rows never share the same monster column.)\n\nTwo cells \\((r_1, c_1)\\) and \\((r_2, c_2)\\) are said to be adjacent if either they lie in the same row and their column indices differ by exactly \\(1\\), or they lie in the same column and their row indices differ by exactly \\(1\\).\n\nA single attempt is a path of cells \\((r_0,c_0)\\), \\((r_1,c_1)\\), \\dots, \\((r_k,c_k)\\) such that:\\\\\n1. The first cell of the path lies in the top row \\(r_00\\).\\\\\n2. Every consecutive pair of cells in the path is adjacent. \\\\\n3. Either the last cell of the path lies in the bottom row \\(r_k2023\\), or else it is a cell containing a monster (in one of the rows \\(1\\) through \\(2022\\)).\n\nWe say an attempt reaches the last row if its final cell lies in row \\(2023\\), and it hits a monster if its final cell is a monster cell in some row from \\(1\\) to \\(2022\\).\\\\\nTurbo's goal is to discover a path from the top row (\\(r0\\)) to the bottom row (\\(r2023\\)) that avoids all monsters. However, Turbo does not know in advance where the monsters are placed. After each attempt that hits a monster, Turbo learns (at least) which cell that final monster occupied, and can use this information in the next attempt to avoid or circumvent monsters.\n\nFormally, we say Turbo has a strategy in at most \\(n\\) attempts if, for any arrangement of monsters satisfying the above conditions, Turbo can make at most \\(n\\) attempts, each possibly informed by the outcomes of the previous attempts, and ensure that at least one of those attempts reaches the bottom row. Denote by \\(\\mathrm{TurboHasStrategy}(n)\\) the statement ``Turbo can guarantee success in at most \\(n\\) attempts.''\n\nLet \\(\\textit{solution\\_value}\\) be the (optimal) number of attempts needed so that \\(\\mathrm{TurboHasStrategy}\\bigl(\\textit{solution\\_value}\\bigr)\\) holds, and moreover no smaller number of attempts can always guarantee a successful path. Prove that \\(\\textit{solution\\_value}\\) is the greatest element of the set\n\\[\n\\{\\,n \\mid \\mathrm{TurboHasStrategy}(n)\\}.\n\\]\n\nIn other words, show that Turbo can indeed guarantee reaching the bottom row in \\(\\textit{solution\\_value}\\) attempts, and cannot do so (for all possible monster placements) in fewer.\n\\end{tcolorbox}\n\n\\begin{tcolorbox}[enhanced, breakable, rounded corners,\n   colbackgreen!5!white, colframegreen!75!black,\n   colbacktitlegreen!85!black, fonttitle\\bfseries, coltitlewhite, titleLean Theorem for 2024 IMO Problem 3]\n\\setlength{\\parskip}{1em}\n\\begin{lstlisting}[\nlanguagePython, basicstyle\\scriptsize\\ttfamily, numbersleft, breaklinestrue, breakatwhitespacetrue, xleftmargin2em, xrightmargin2em, aboveskip1em, belowskip1em, mathescapetrue\n]\n\nimport Mathlib.Tactic\nimport Mathlib.Data.Nat.Basic\nimport Mathlib.Data.Finset.Basic\n\nnamespace IMO2024P3\n\n/--\nAn infinite sequence of positive integers indexed by natural numbers\nstarting from 1. We represent it as a function $a : \\mathbb{N} \\to \\mathbb{N}$ with the\nconvention that $a(0)$ corresponds to $a_{1}$, $a(1)$ to $a_{2}$, and so on.\nThus, $a(n)$ represents $a_{n+1}$ in the original statement.\n-/\ndef InfiniteSequence : $\\mathbb{N} \\to \\mathbb{N}$\n\n/--\nWe say that $a$ is *valid* with respect to a positive integer $N$ if for each\n$n > N$, the value of $a(n)$ is the number of times $a(n - 1)$ appears in\nthe list $a(0), a(1), \\dots, a(n - 1)$. In other words, for each $n > N$,\n$a_{n+1}$ is the count of how many times $a_{n}$ appears in $a_{1}, a_{2}, \\dots, a_{n}$.\n-/\ndef valid_sequence (a : InfiniteSequence) (N : $\\mathbb{N}$) : Prop :\n   $\\forall$ (n : $\\mathbb{N}$), n > N $\\to$\n   a n   (Finset.filter (fun k > a k   a (n - 1)) (Finset.range n)).card\n\n/--\nAn infinite sequence $b$ is *eventually periodic* if there exist positive\nintegers $p$ and $M$ such that for all $m \\geq M$, we have $b(m + p)   b(m)$.\n-/\ndef eventually_periodic (b : InfiniteSequence) : Prop :\n   $\\exists$ (p M : $\\mathbb{N}$), p > 0 $\\land$   $\\forall$ m $\\geq$ M, b (m + p)   b m\n\n/--\nGiven an infinite sequence of positive integers $a$ (where $a(n)$ stands for\n$a_{n+1}$), and a positive integer $N$ satisfying the condition that for\neach $n > N$, $a_{n+1}$ is the number of times $a_{n}$ appears among\n$a_{1}, a_{2}, \\dots, a_{n}$, prove that at least one of the subsequences\n$a_{1}, a_{3}, a_{5}, \\dots$ and $a_{2}, a_{4}, a_{6}, \\dots$ is eventually periodic.\n\nIn our indexing scheme:\n- the \"odd subsequence\" corresponds to $a(0), a(2), a(4), \\dots$\n- the \"even subsequence\" corresponds to $a(1), a(3), a(5), \\dots$\n-/\ntheorem imo_new_problem\n   (a : InfiniteSequence) (N : \\mathbb{N}) (hpos : \\forall n, a n > 0) (hvalid : valid_sequence a N) :\n   eventually_periodic (fun m > a (2 * m)) \\lor eventually_periodic (fun m > a (2 * m + 1)) :\nsorry\n\nend IMO2024P3\n\\end{lstlisting}\n\\end{tcolorbox}\n\n\\subsection*{2024 USAMO}\n\\begin{tcolorbox}[enhanced, breakable, rounded corners,\n   colbackgreen!5!white, colframegreen!75!black,\n   colbacktitlegreen!85!black, fonttitle\\bfseries, coltitlewhite, titleLean Theorem for 2024 USAMO Problem 2]\n\\setlength{\\parskip}{1em}\n\\begin{lstlisting}[\nlanguagePython, basicstyle\\scriptsize\\ttfamily, numbersleft, breaklinestrue, breakatwhitespacetrue, xleftmargin2em, xrightmargin2em, aboveskip1em, belowskip1em, mathescapetrue\n]\nimport Mathlib.Data.Finset.Basic\nimport Mathlib.Data.Nat.Basic\nimport Mathlib.Tactic\n\nnamespace USAMO2024P2\n\n/--\nWe have 100 finite sets of integers, $S_{1}, S_{2}, \\dots, S_{100}$, with the following properties:\n\n1. Their overall intersection is non-empty, i.e. ($\\bigcap i, S_i$).Nonempty.\n2. For every non-empty subset T of the indices {$0,1,\\dots,99$} (representing a choice of sets),\n   the cardinality of the intersection of S_{i} for $i \\in T$ is a multiple of the number of sets in T.\n\nWe want to find the least possible number of elements that lie in at least 50 of these sets.\n-/\nstructure GoodFamily (S : Fin 100 $\\to$ Finset $\\mathbb{Z}$) : Prop where\n   nonempty_intersection : ($\\bigcap i, S_i$).Nonempty\n   multiple_property :\n   $\\forall$ (T : Finset (Fin 100)), T.Nonempty $\\to$\n   T.card | ($\\bigcap$ (i : Fin 100) (_ : $i \\in T), S_i$).card\n\n/--\nThe number of elements that are contained in at least 50 of the sets $S_{i}$.\n-/\ndef countInAtLeast50 (S : Fin 100 $\\to$ Finset $\\mathbb{Z}$) : $\\mathbb{N}$ :\n   (SetOf fun (x : $\\mathbb{Z}$) >\n   50 $\\leq$ (Finset.univ.filter fun i : Fin $100 \\Rightarrow x \\in S_i$).card\n   ).toFinset.card\n\n/--\nWe denote by solution\\_value the minimal possible value of countInAtLeast50 S\namong all families of sets $S$ satisfying the above properties.\n-/\nabbrev solution_value : $\\mathbb{N}$ : sorry\n\n/--\nRestatement of the problem: Determine (prove a formula or evaluate) the least possible\nnumber of elements that lie in at least 50 of the sets S_{i}, subject to the given conditions.\n-/\ntheorem USAMO2024P2 :\n   IsLeast { c | $\\exists$ (S : Fin 100 $\\to$ Finset $\\mathbb{Z}$), GoodFamily S $\\land$   countInAtLeast50 S   c }\n   (solution_value) : sorry\n\nend USAMO2024P2\n\\end{lstlisting}\n\\end{tcolorbox}\n\n\\begin{tcolorbox}[enhanced, breakable, rounded corners,\n   colbackgreen!5!white, colframegreen!75!black,\n   colbacktitlegreen!85!black, fonttitle\\bfseries, coltitlewhite, titleLean Theorem for 2024 USAMO Problem 4]\n\\setlength{\\parskip}{1em}\n\\begin{lstlisting}[\nlanguagePython, basicstyle\\scriptsize\\ttfamily, numbersleft, breaklinestrue, breakatwhitespacetrue, xleftmargin2em, xrightmargin2em, aboveskip1em, belowskip1em, mathescapetrue\n]\nimport Mathlib.Tactic\nimport Mathlib.Data.Fin.Basic\nimport Mathlib.Data.Finset.Basic\nimport Mathlib.Algebra.BigOperators.Basic\n\nnamespace USAMO2024P4\n\n/--\nA $necklace$ of length $N$ is given by a function from $Fin N$ to $Bool$\n($true$ for red and $false$ for blue).\n-/\nstructure necklace (N : $\\mathbb{N}$) where\n   color : Fin N $\\to$ Bool\n\n/--\nFor a necklace with $m * n$ beads (arranged circularly), a cut position\n$s : Fin (m * n)$ partitions the necklace into $m$ blocks, each of length $n$.\nSpecifically, the $i$-th block (where $i : Fin m$) consists of the beads\nwhose indices range from $s + i * n$ to $s + i * n + n - 1$ (taken modulo $m * n$).\n-/\ndef block_indices (m n : $\\mathbb{N}$) (s : Fin (m * n)) (i : Fin m) : Finset (Fin (m * n)) :\n   -- The set of indices (mod m*n) belonging to the i-th block after a cut at s.\n   Finset.image ($\\lambda$ k : Fin n $\\Rightarrow$ $\\langle$ (s + i * n + k)   (m * n), sorry_proof$\\rangle$ ) (Finset.univ)\n\n/--\n$block_red_count m n col s_i$ is the number of red beads in the $i$-th block\n(after cutting at position $s$).\n-/\ndef block_red_count (m n : $\\mathbb{N}$) (col : necklace (m * n)) (s : Fin (m * n)) (i : Fin m) : $\\mathbb{N}$ :\n   (block_indices m n s_i).filter (lambda x > col.color x).card\n\n/--\nWe say that a given cut position $s$ has the \"distinct-blocks\" property\nif, for that cut, each of the $m$ blocks has a *distinct* number of red beads.\n-/\ndef distinct_blocks_for_cut (m n : $\\mathbb{N}$) (col : necklace (m * n)) (s : Fin (m * n)) : Prop :\n   Function.Injective ($\\lambda$ i : Fin m > block_red_count m n col s_i)\n\n/--\nThe $distinct_blocks_property$ holds for a necklace if *every* cut position\nproduces $m$ blocks having distinct red-bead counts.\n-/\ndef distinct_blocks_property (m n : $\\mathbb{N}$) (col : necklace (m * n)) : Prop :\n   $\\forall$ s : Fin (m * n), distinct_blocks_for_cut m n col s\n\n/--\nA pair $(m, n)$ is *admissible* if there exists a necklace of length $m * n$\nsuch that no matter how we cut the necklace into $m$ consecutive blocks\nof length $n$, each block has a distinct number of red beads.\n-/\ndef admissible (m n : $\\mathbb{N}$) : Prop :\n   $\\exists$ (col : necklace (m * n)), distinct_blocks_property m n col\n\n/--\n**USAMO2024P4** :\n\n\"Let $m$ and $n$ be positive integers. A circular necklace contains $m * n$ beads,\neach either red or blue. It turned out that no matter how the necklace was cut\ninto $m$ blocks of $n$ consecutive beads, each block had a distinct number of red beads.\nDetermine all possible values of the ordered pair $(m, n)$.\"\n\nThis theorem statement encodes: \"Classify or determine all $(m, n)$ for which\nan admissible necklace exists.\"\n-/\ntheorem USAMO2024P4 (m n : $\\mathbb{N}$) (hm : 0 < m) (hn : 0 < n) :\n   admissible m n $\\iff$ sorry :\nsorry\n\nend USAMO2024P4\n\\end{lstlisting}\n\\end{tcolorbox}\n\n\\subsection*{2023 IMO Shortlist}\n\\begin{tcolorbox}[enhanced, breakable, rounded corners,\n   colbackgreen!5!white, colframegreen!75!black,\n   colbacktitlegreen!85!black, fonttitle\\bfseries, coltitlewhite, titleLean Theorem for 2023 IMO Shortlist Combinatorics Problem 1]\n\\setlength{\\parskip}{1em}\n\\begin{lstlisting}[\nlanguagePython, basicstyle\\scriptsize\\ttfamily, numbersleft, breaklinestrue, breakatwhitespacetrue, xleftmargin2em, xrightmargin2em, aboveskip1em, belowskip1em, mathescapetrue\n]\nimport Mathlib.Tactic\nimport Mathlib.Data.Nat.Basic\n\nnamespace IMO2023SLC1\n\n/--\nA coin can be in one of two states: heads or tails.\nWe represent this by a simple inductive type.\n-/\ninductive CoinSide\n| heads\n| tails\n\nopen CoinSide\n\n/--\nFlip a coin from heads to tails or from tails to heads.\n-/\ndef flip (c : CoinSide) : CoinSide :\n   match c with\n   | heads > tails\n   | tails > heads\n\n/--\nAn $m\\times n$ grid of coins, each coin has a row index $0 \\leq r < m$\nand a column index $0 \\leq c < n$.\n-/\nstructure Grid (m n : $\\mathbb{N}$) where\n   coin : Fin m $\\to$ Fin n $\\to$ CoinSide\n\n/--\nThe initial configuration: every coin is tails.\n-/\ndef initialGrid (m n : $\\mathbb{N}$) : Grid m n :\n   { coin : fun _ _ > tails }\n\n/--\nCheck whether every coin in the grid is heads.\n-/\ndef allHeads {m n : $\\mathbb{N}$} (g : Grid m n) : Prop :\n   $\\forall$ (r : Fin m) (c : Fin n), g.coin r c   heads\n\n/--\nA move is defined by:\n1. Selecting the top-left coordinate of a valid $2 \\times 2$ square,\n2. Flipping the coins in the top-left and bottom-right cells,\n3. Choosing exactly one of the remaining two diagonal cells\n   (top-right or bottom-left) to flip as well.\n\nWe capture this choice by storing:\n- The row and column of the top-left corner of the $2 \\times 2$ square,\n- A boolean (or similar) to indicate which diagonal coin to flip.\n   For example, if $diagFlip   true$, flip the top-right coin;\n   otherwise, flip the bottom-left coin.\n-/\nstructure Move (m n : $\\mathbb{N}$) where\n   (row : Fin (m - 1))\n   (col : Fin (n - 1))\n   (diagFlip : Bool)   -- true means flip top-right; false means flip bottom-left\n\n/--\nApply a single move to a grid:\n- Flip the coins at top-left $(row, col)$ and bottom-right $(row+1, col+1)$.\n- Then flip exactly one of the coins at $(row, col+1)$ or $(row+1, col)$,\n   depending on the boolean flag in the move.\n-/\ndef applyMove {m n : $\\mathbb{N}$} (g : Grid m n) (mv : Move m n) : Grid m n :\n   let row_{0} : mv.row\n   let col_{0} : mv.col\n   let flipDiag : mv.diagFlip\n\n   -- Helper to flip exactly one cell\n   let flipCell (r : Fin m) (c : Fin n) (g : Grid m n) : Grid m n :\n   { coin : fun r' c' >\n   if r'   r $\\land$   c'   c\n   then flip (g.coin r' c')\n   else g.coin r' c' }\n\n   -- Flip top-left\n   let $g_{1}$ : flipCell $row_{0}$ $col_{0}$ g\n   -- Flip bottom-right\n   let $g_{2}$ : flipCell ($\\langle row_{0} + 1, Nat.lt_of_lt_pred row_{0}.isLt\\rangle$ )\n   (\\langle col_{0} + 1, Nat.lt_of_lt_pred col_{0}.isLt\\rangle )\n   $g_{1}$\n   -- Flip either top-right or bottom-left\n   if flipDiag then\n   -- Flip top-right\n   flipCell $row_{0} (\\langle col_{0} + 1, Nat.lt_of_lt_pred col_{0}.isLt\\rangle ) g_{2}$\n   else\n   -- Flip bottom-left\n   flipCell ($\\langle row_{0} + 1, Nat.lt_of_lt_pred row_{0}.isLt\\rangle$ ) $col_{0} g_{2}$\n\n/--\nWe say that it is \"possible\" to turn all coins heads-up if\nthere exists a finite sequence of valid moves that transforms\nthe $initialGrid$ (all tails) into a grid with $allHeads$.\n-/\ndef possible (m n : $\\mathbb{N}$) : Prop :\n   $\\exists$ (moves : List (Move m n)),\n   let finalGrid : moves.foldl (fun g mv > applyMove g mv) (initialGrid m n)\n   in allHeads finalGrid\n\n/--\nMain theorem statement (to be proved):\nDetermine all pairs $(m, n)$ (with $1 < m$ and $1 < n$) for which\nit is possible to obtain a configuration where every coin is heads\nafter a finite number of moves as described.\n\nThe actual classification of such $(m, n)$ is omitted here\nand replaced by $sorry$. \n-/\ntheorem imoNewProblem (m n : $\\mathbb{N}$) (hm : 1 < m) (hn : 1 < n) :\n   possible m n $\\iff$ -- \"$\\iff$\" replaced with the actual condition describing all valid (m, n).\n   sorry : sorry\n\nend IMO2023SLC1\n\\end{lstlisting}\n\\end{tcolorbox}\n\n\\begin{tcolorbox}[enhanced, breakable, rounded corners,\n   colbackgreen!5!white, colframegreen!75!black,\n   colbacktitlegreen!85!black, fonttitle\\bfseries, coltitlewhite, titleLean Theorem for 2023 IMO Shortlist Combinatorics Problem 2]\n\\setlength{\\parskip}{1em}\n\\begin{lstlisting}[\nlanguagePython, basicstyle\\scriptsize\\ttfamily, numbersleft, breaklinestrue, breakatwhitespacetrue, xleftmargin2em, xrightmargin2em, aboveskip1em, belowskip1em, mathescapetrue\n]\nimport Mathlib.Tactic\nimport Mathlib.Data.Fintype.Basic\nimport Mathlib.Data.Nat.Basic\n\nnamespace IMO2023SLC2\n\n/--\nA sequence of nonempty length $L$ in which the terms are given by $seq : Fin L \\to \\mathbb{N}$.\n-/\nstructure IntSequence (L : $\\mathbb{N}$) where\n   seq : Fin $L \\to \\mathbb{N}$\n\n/--\nStates that every term of the given sequence is a positive integer and is bounded above by $2^2023$.\n-/\ndef is_positive_bounded {L : \\mathbb{N}} (S : IntSequence L) : Prop :\n   $\\forall$ i : Fin L, 0 < S.seq i $\\land$   S.seq i $\\leq 2^{2023}$\n\n/--\nStates that there is no *consecutive* subsequence of $S$ (from index $i$ to $j$ with $i \\leq j$)\nand no choice of signs $\\pm 1$ such that the signed sum of that subsequence is zero.\n-/\ndef no_consecutive_zero_sum {L : \\mathbb{N}} (S : IntSequence L) : Prop :\n   $\\forall$ (i j : $\\mathbb{N}$), $i \\leq j \\to j < L \\to i < L \\to$\n   $ \\neg \\exists$ (sign : Fin (j - i + 1) $\\to \\mathbb{Z}$),\n   ($\\forall$ x, sign x   1 $\\lor$ sign x   -1) $\\land $\n   $\\sum x$, sign x * S.seq $\\langle i + x.val, by linarith\\rangle   0$\n\n/--\nA sequence is *valid* if:\n\n1. Every term is a positive integer bounded by $2^2023$.\n2. There is no consecutive subsequence with a signed sum of zero.\n-/\ndef is_valid_sequence {L : $\\mathbb{N}$} (S : IntSequence L) : Prop :\n   is_positive_bounded S $\\land$   no_consecutive_zero_sum S\n\n/--\n$maximal_length$ is the maximum possible $L$ for which there\nexists a valid sequence of length $L$.\n-/\ndef maximal_length : $\\mathbb{N}$ :\n   sorry   -- to be determined\n\n/--\nThe main statement: the maximal length of such a sequence is $maximal_length$.\n-/\ntheorem determine_maximal_length :\n   IsGreatest { L | $\\exists$ S : IntSequence L, is_valid_sequence S } maximal_length :\nsorry\n\nend IMO2023SLC2\n\\end{lstlisting}\n\\end{tcolorbox}\n\n\n\\begin{tcolorbox}[enhanced, breakable, rounded corners,\n   colbackgreen!5!white, colframegreen!75!black,\n   colbacktitlegreen!85!black, fonttitle\\bfseries, coltitlewhite, titleLean Theorem for 2023 IMO Shortlist Combinatorics Problem 3]\n\\setlength{\\parskip}{1em}\n\\begin{lstlisting}[\nlanguagePython, basicstyle\\scriptsize\\ttfamily, numbersleft, breaklinestrue, breakatwhitespacetrue, xleftmargin2em, xrightmargin2em, aboveskip1em, belowskip1em, mathescapetrue\n]\nimport Mathlib.Data.Fintype.Card\nimport Mathlib.Tactic\n\nnamespace IMO2023SLC3\n\n/--\nA triangle of $n$ rows where the $i$th row contains exactly $i$ circles.\nExactly one circle in each row is colored red.\n-/\nstructure Triangle (n : $\\mathbb{N}$) where\n   /--\n   $red i$ is the index (from $0$ to $i-1$) of the red circle in the $i$th row,\n   where rows are indexed by $i : Finset.Icc 1 n$. Note that $i.val$ is the\n   natural number corresponding to the row index, hence we use $Fin i.val$.\n   -/\n   red : (i : Finset.Icc 1 n) $\\to$ Fin i.val\n\n/--\nHelper function to move from row $i$ to row $i+1$ (when $i.val+1 $\\leq$ n$).\n-/\ndef next_row {n :$ \\mathbb{N}$} (i : Finset.Icc 1 n) (h : i.val + 1 $\\leq$ n) : Finset.Icc 1 n :\n   $\\langle i.val + 1, h\\rangle $\n\n/--\nA ninja-path in a triangle of $n$ rows is determined by choosing exactly\none circle from each row in such a way that if you are on circle $j$ in row $i$,\nthen the circle in row $i+1$ must be either $j$ or $j+1$.\n-/\nstructure NinjaPath (n : $\\mathbb{N}$) where\n   /--\n   For each row $i$, $steps i$ gives the index of the chosen circle\n   in that row (index in $0..(i-1)$).\n   -/\n   steps : (i : Finset.Icc 1 n) $\\to$ Fin i.val\n\n   /--\n   The path condition: from circle $steps i$ in row $i$, you can only move to\n   circle $steps (i+1)$ in row $i+1$ whose index is either the same or one greater.\n   -/\n   steps_valid :\n   $\\forall$ (i : Finset.Icc 1 n) (h : i.val + 1 $\\leq$ n),\n   (steps i).val   (steps (next_row i h)).val $\\lor$\n   (steps i).val + 1   (steps (next_row i h)).val\n\n/--\n$largest_k n$ will be the maximum number of red circles that a ninja-path\ncan always guarantee to pass through, regardless of how the single red circle\nin each row is placed.\n-/\nabbrev largest_k (n : $\\mathbb{N}$) : $\\mathbb{N}$ :\n   sorry   -- This is where one would define or compute the exact value of k.\n\n/--\nMain statement: for any way of coloring one circle red in each row of an\n$n$-row triangle, there is always a ninja-path containing at least $largest_k n$\nred circles. Moreover, $largest_k n$ is the maximal such value satisfying\nthis universal condition.\n-/\ntheorem find_max_red_circles (n : $\\mathbb{N}$) :\n   IsGreatest\n   { k | $\\forall$ T : Triangle n, $\\exists$ p : NinjaPath n, k $\\leq$ Fintype.card { i // T.red i   p.steps i } }\n   (largest_k n) : sorry\n\nend IMO2023SLC3\n\\end{lstlisting}\n\\end{tcolorbox}\n\n\n\\begin{tcolorbox}[enhanced, breakable, rounded corners,\n   colbackgreen!5!white, colframegreen!75!black,\n   colbacktitlegreen!85!black, fonttitle\\bfseries, coltitlewhite, titleLean Theorem for 2023 IMO Shortlist Combinatorics Problem 4]\n\\setlength{\\parskip}{1em}\n\\begin{lstlisting}[\nlanguagePython, basicstyle\\scriptsize\\ttfamily, numbersleft, breaklinestrue, breakatwhitespacetrue, xleftmargin2em, xrightmargin2em, aboveskip1em, belowskip1em, mathescapetrue\n]\nimport Mathlib.Tactic\n\nnamespace IMO2023SLC4\n\n/--\nAn arrangement of labels $1, 2, \\dots, n^2$ into an $n \\times n$ grid.\nHere, $label i j$ is the integer in the $(i+1)$-th row and $(j+1)$-th column (0-based indexing in Lean),\nand we require it to lie between $1$ and $n^2$.\n-/\nstructure Arrangement (n : $\\mathbb{N}$) where\n   label : Fin n $\\to$ Fin n \\to \\mathbb{N}\n   label_range : $\\forall$ i j, 1 $\\leq$ label i j $\\land$   label i j $\\leq$ n^2\n   /--\n   The divisibility property: for each square in the $(i+1)$-th row and $(j+1)$-th column,\n   $label i j - (i + j + 1 - 1)$ (which corresponds to $a_{i+1,j+1} - ( (i+1) + (j+1) - 1 )$\n   in 1-based indexing) is divisible by $n$.\n   -/\n end IMO2023SLC4\n\\end{lstlisting}\n\\end{tcolorbox}\n\n\\begin{tcolorbox}[enhanced, breakable, rounded corners,\n   colbackgreen!5!white, colframegreen!75!black,\n   colbacktitlegreen!85!black, fonttitle\\bfseries, coltitlewhite, titleLean Theorem for 2023 IMO Shortlist Combinatorics Problem 5]\n\\setlength{\\parskip}{1em}\n\\begin{lstlisting}[\nlanguagePython, basicstyle\\scriptsize\\ttfamily, numbersleft, breaklinestrue, breakatwhitespacetrue, xleftmargin2em, xrightmargin2em, aboveskip1em, belowskip1em, mathescapetrue\n]\nimport Mathlib.Tactic\nimport Mathlib.Data.Finset.Basic\nimport Mathlib.Data.Nat.Basic\n\nnamespace IMO2023SLC5\n\n/--\nA configuration of the 2023 chests on a given day.\n\n$\\textbullet{}$ $gems i$ is the number of gems in chest $i$.\n$\\textbullet{}$ $unlocked$ is the set of chests that are unlocked.\n-/\nstructure ChestConfig where\n   gems : Fin 2023 $\\to \\mathbb{N}$\n   unlocked : Finset (Fin 2023)\n\n/--\nElisa's move: she must add a gem to one of the currently unlocked chests.\nAn \"Elisa strategy\" can be seen as a function that, given the current\nconfiguration, selects an unlocked chest in which to place the new gem.\n-/\nabbrev ElisaStrategy : ChestConfig $\\to$ Fin 2023\n\n/--\nFairy's move: after Elisa places a gem, if more than one chest is unlocked,\nthe fairy locks exactly one of those unlocked chests. If there is exactly\none unlocked chest, the fairy unlocks all chests.\nA \"Fairy strategy\" can be seen as a function that, given the current\nconfiguration (after Elisa has placed her gem), decides which chest to lock\n(or decides to unlock all, if only one is unlocked).\n-/\nabbrev FairyStrategy : ChestConfig $\\to$ Option (Fin 2023)\n/-\nInterpretation of $FairyStrategy$:\n$\\textbullet{}$ If $fairy cfg   some c$, then the fairy locks chest $c$ (which must be in $cfg.unlocked$).\n$\\textbullet{}$ If $fairy cfg   none$, then the fairy unlocks all chests.\n-/\n\n/--\nA valid transition from $cfg$ to $cfg'$ consists of:\n1. Elisa places a gem in an unlocked chest $e$ chosen by her strategy.\n2. If $cfg.unlocked$ had more than one chest, then the fairy locks exactly\n   one unlocked chest $f$ chosen by its strategy. Otherwise, if there was\n   exactly one unlocked chest, the fairy unlocks all chests.\n\nThis definition is just a *specification* of a one-step update rule; we do not\nfully enforce correctness conditions here but illustrate how one might encode\nthem. In a full formal proof, we would ensure:\n   - $e \\in cfg.unlocked$\n   - if $cfg.unlocked$ has card > 1, then $f \\in cfg.unlocked$\n   - if $cfg.unlocked$ has card   1, then $f   none$ (unlock all)\netc.\n-/\ndef valid_transition \n   (elisa : ElisaStrategy) (fairy : FairyStrategy)\n   (cfg cfg' : ChestConfig) : Prop :\nlet e : elisa cfg in\nlet f : fairy ($\\langle$ fun i > if i   e then cfg.gems i + 1 else cfg.gems i,\n   cfg.unlocked$\\rangle$ ) in\n-- Construct $cfg'$ by adding Elisa's gem and applying the fairy's choice\ncfg'.gems   fun i > if i   e then cfg.gems i + 1 else cfg.gems i\n$\\land$   match f with\n   | some chest_to_lock >\n   cfg.unlocked.card > 1\n   $\\land$   cfg'.unlocked   cfg.unlocked.erase chest_to_lock\n   | none >\n   cfg.unlocked.card   1\n   $\\land$   cfg'.unlocked   Finset.univ\n   end\n\n/--\nWe say that an infinite sequence of configurations $s : \\mathbb{N} \\to ChestConfig$\nrespects strategies $(elisa, fairy)$ if each successive pair $(s n, s (n+1))$\nis a valid transition using those strategies.\n-/\ndef respects_strategies \n   (elisa : ElisaStrategy) (fairy : FairyStrategy)\n   (s : $\\mathbb{N} \\to$ ChestConfig) : Prop :\n$\\forall$ n : $\\mathbb{N}$, valid_transition elisa fairy (s n) (s (n+1))\n\n/--\nA statement of the main property:\n\n\"There exists a constant $C$ such that Elisa can ensure, no matter how the\nfairy acts, that for every pair of chests $i, j$ and for all times $t$,\nthe difference in the number of gems between chest $i$ and chest $j$\nis at most $C$.\"\n\nFormally, we assert the existence of:\n\n$\\textbullet{}$ A natural number $C$.\n$\\textbullet{}$ An Elisa strategy $elisa$.\n\nsuch that for *every* fairy strategy $fairy$, if $s$ is an infinite sequence\nof valid configurations (starting from all chests unlocked and empty) that\nrespects $(elisa, fairy)$, then for all times $t$ and all chests $i, j$,\nwe have $|s(t).gems i - s(t).gems j| \\leq C$.\n-/\ntheorem imo2023_chests :\n   $\\exists$ (C : $\\mathbb{N}$) (elisa : ElisaStrategy),\n   $\\forall$ (fairy : FairyStrategy),\n   $\\forall$ (s : $\\mathbb{N}$ $\\to$ ChestConfig)\n   (hstart : s 0   \n   { gems : fun _ > 0,\n   unlocked : Finset.univ } )\n   (hrespect : respects_strategies elisa fairy s),\n   $\\forall$ (t :$ \\mathbb{N}$) (i j : Fin 2023),\n   (s t).gems i $\\leq$ (s t).gems j + C\n   $\\land$   (s t).gems j $\\leq$ (s t).gems i + C :\nsorry\n\nend IMO2023SLC5\n\\end{lstlisting}\n\\end{tcolorbox}\n\n\n\\begin{tcolorbox}[enhanced, breakable, rounded corners,\n   colbackgreen!5!white, colframegreen!75!black,\n   colbacktitlegreen!85!black, fonttitle\\bfseries, coltitlewhite, titleLean Theorem for 2023 IMO Shortlist Combinatorics Problem 6]\n\\setlength{\\parskip}{1em}\n\\begin{lstlisting}[\nlanguagePython, basicstyle\\scriptsize\\ttfamily, numbersleft, breaklinestrue, breakatwhitespacetrue, xleftmargin2em, xrightmargin2em, aboveskip1em, belowskip1em, mathescapetrue\n]\nimport Mathlib.Tactic\nimport Mathlib.Data.Finset.Basic\n\nnamespace IMO2023SLC6\n\n/--\nA coordinate in an N$\\times$ N grid, with 0 $\\leq$ row, col < N.\n-/\nstructure GridCoords (N : $\\mathbb{N}$) where\n   row : Fin N\n   col : Fin N\n\n/--\nA \"right-down\" adjacency between two cells means that the second cell\nis either directly to the right (same row, next column) or directly\nbelow (next row, same column) of the first.\n-/\ndef is_adj_right_down {N : $\\mathbb{N}$} (c_{1} c_{2} : GridCoords N) : Prop :\n   (c_{2}.row   c_{1}.row $\\land$   c_{2}.col   c_{1}.col.succ) $\\lor$\n   (c_{2}.col   c_{1}.col $\\land$   c_{2}.row   c_{1}.row.succ)\n\n/--\nA \"right-down\" path is a finite list of cells in the grid such that\neach consecutive pair of cells satisfies $is_adj_right_down$.\n-/\ndef is_right_down_path {N : $\\mathbb{N}$} (p : List (GridCoords N)) : Prop :\n   $\\forall$ i, i + 1 < p.length $\\to$ is_adj_right_down (p.nthLe i (by simp)) (p.nthLe (i+1) (by simp))\n\n/--\nA \"right-up\" adjacency between two cells means that the second cell\nis either directly to the right (same row, next column) or directly\nabove (previous row, same column) of the first.\n-/\ndef is_adj_right_up {N : $\\mathbb{N}$} ($c_{1} c_{2}$ : GridCoords N) : Prop :\n   $(c_{2}.row   c_{1}.row \\land   c_{2}.col   c_{1}.col.succ) \\lor\n   (c_{2}.col   c_{1}.col \\land   c_{1}.row   c_{2}.row.succ)$\n\n/--\nA \"right-up\" path is a finite list of cells in the grid such that\neach consecutive pair of cells satisfies $is_adj_right_up$.\n-/\ndef is_right_up_path {N : $\\mathbb{N}$} (p : List (GridCoords N)) : Prop :\n   $\\forall$ i, i + 1 < p.length $\\to$ is_adj_right_up (p.nthLe i (by simp)) (p.nthLe (i+1) (by simp))\n\n/--\nA path that is either right-down or right-up.\n-/\ndef is_rd_or_ru_path {N :$ \\mathbb{N}$} (p : List (GridCoords N)) : Prop :\n   is_right_down_path p $\\lor$ is_right_up_path p\n\n/--\nA partition of the N$\\times$ N grid into a family of right-down or right-up paths means:\n1. Every cell of the grid appears in exactly one path in the family.\n2. Each path in the family is a right-down or right-up path.\n-/\nstructure PartitionIntoPaths (N : $\\mathbb{N}$) where\n   paths : List (List (GridCoords N))\n   covers   : ($\\bigcup$ (p $\\in$ paths) , p.toFinset)   \n   (Finset.univ : Finset (GridCoords N))\n   disjoint : $\\forall (p_{1} p_{2} \\in paths), p_{1} \\neq p_{2} \\to \n   (p_{1}.toFinset \\bigcap p_{2}.toFinset)   \\emptyset$\n   valid   : $\\forall (p \\in paths), is_rd_or_ru_path p$\n\n/--\n**The main theorem**: The cells of an N$\\times$ N grid cannot be partitioned into\nfewer than N right-down or right-up paths.\n-/\ntheorem grid_partition_lower_bound (N : $\\mathbb{N}$) (hN : 0 < N) :\n   $\\forall$ (P : PartitionIntoPaths N), P.paths.length $\\geq$ N : by\n   /-\n   **Proof Sketch (to be completed):**\n   1. Argue by contradiction: assume there is a partition with fewer than N paths.\n   2. Derive a counting or combinatorial contradiction by examining rows/columns.\n   3. Conclude that at least N paths are necessary.\n\n   The details of the proof are omitted here; they would replicate the\n   standard arguments from the original IMO-style solution.\n   -/\n   sorry\n\nend IMO2023SLC6\n\\end{lstlisting}\n\\end{tcolorbox}\n\n\\begin{tcolorbox}[enhanced, breakable, rounded corners,\n   colbackgreen!5!white, colframegreen!75!black,\n   colbacktitlegreen!85!black, fonttitle\\bfseries, coltitlewhite, titleLean Theorem for 2023 IMO Shortlist Combinatorics Problem 7]\n\\setlength{\\parskip}{1em}\n\\begin{lstlisting}[\nlanguagePython, basicstyle\\scriptsize\\ttfamily, numbersleft, breaklinestrue, breakatwhitespacetrue, xleftmargin2em, xrightmargin2em, aboveskip1em, belowskip1em, mathescapetrue\n]\nimport Mathlib.Tactic\nimport Mathlib.Combinatorics.SimpleGraph.Basic\n\n/- \n   We formalize the Imomi archipelago problem:\n\n   We have n $\\geq$ 2 islands. Each pair of distinct islands has a unique ferry line \n   running in both directions, and each ferry line is operated by exactly one \n   of k companies. \n\n   It is known that if any one of the k companies closes all its ferry lines, \n   the resulting network no longer admits a route visiting each island exactly once \n   (i.e., no Hamiltonian path exists in that subgraph). \n\n   We want to determine the maximum possible number k of companies, in terms of n.\n-/\n\nnamespace IMO2023SLC7\n\n/--\nA structure representing an assignment of ferry lines (edges in a complete graph on $n$ vertices)\nto $k$ companies. Here, the function $company_of$ assigns each unordered pair of distinct islands\n($Sym2 (Fin n)$) to one of the $k$ companies.\n\nAdditionally, we record the condition that if we remove from the complete graph all edges operated\nby any one company, the resulting graph has no Hamiltonian path.\n-/\nstructure Archipelago (n k : $\\mathbb{N}$) where\n   /-- Assignment of each unordered pair of distinct islands \n   to a company numbered in $Fin k$. -/\n   company_of : Sym2 (Fin n) $\\to$ Fin k\n\n   /-- Condition: removing the edges of any single company destroys all Hamiltonian paths. \n   Formally, for each company $c$, the induced subgraph on edges not operated by $c$\n   has no Hamiltonian path. -/\n   no_hamiltonian_if_company_removed :\n   $\\forall$ c : Fin k,\n   $\\neg$ hasHamiltonianPath\n   ((SimpleGraph.complete (Fin n)).spanningSubgraph\n   (lambda e, company_of e $\\neq$ c))\n\n/--\n$max_possible_k n$ is defined as the maximal number of companies $k$ such that there exists\nan $Archipelago n k$ satisfying the above condition.\n-/\nabbrev max_possible_k (n : $\\mathbb{N}$) : $\\mathbb{N}$ : sorry\n\n/--\nThe main statement of the problem: for each $n \\geq 2$, the maximum number of companies in\nsuch an archipelago is $max_possible_k n$. We leave $max_possible_k n$ as a $sorry$,\nsince determining its value is exactly the content of the problem.\n-/\ntheorem imomi_archipelago (n : \\mathbb{N}) (hn : 2 \\leq n) :\n   IsGreatest {k | \\exists A : Archipelago n k, True} (max_possible_k n) :\nsorry\n\nend IMO2023SLC7\n\\end{lstlisting}\n\\end{tcolorbox}",
  "title": "main"
}
